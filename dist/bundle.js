!function(g){var I={};function C(n){if(I[n])return I[n].exports;var l=I[n]={i:n,l:!1,exports:{}};return g[n].call(l.exports,l,l.exports,C),l.l=!0,l.exports}C.m=g,C.c=I,C.d=function(g,I,n){C.o(g,I)||Object.defineProperty(g,I,{enumerable:!0,get:n})},C.r=function(g){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})},C.t=function(g,I){if(1&I&&(g=C(g)),8&I)return g;if(4&I&&"object"==typeof g&&g&&g.__esModule)return g;var n=Object.create(null);if(C.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:g}),2&I&&"string"!=typeof g)for(var l in g)C.d(n,l,function(I){return g[I]}.bind(null,l));return n},C.n=function(g){var I=g&&g.__esModule?function(){return g.default}:function(){return g};return C.d(I,"a",I),I},C.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},C.p="",C(C.s=8)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WallState; });\n/* harmony import */ var _MazeEntity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var _Vertex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);\n\n\n\nconst WallState = {\n    PENDING: \'PENDING\',\n    CONFIRMED: \'CONFIRMED\',\n    REMOVED: \'REMOVED\'\n}\n\nclass Wall extends _MazeEntity_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"] {\n    constructor(...args) {\n        super(...args);\n\n        this.state = (\n                this.row === 0 || this.row === this.maze.rows*2 ||\n                this.col === 0 || this.col === this.maze.cols*2\n            ) ? WallState.CONFIRMED : WallState.PENDING;\n    }\n\n    getVertices() {\n        const neighbors = this.getListOfNeighborsAtDist(1);\n        const vertices = neighbors.filter((neighbor) => neighbor instanceof _Vertex_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]);\n        return vertices;\n    }\n\n    isRemovable() {\n        if (this.state !== WallState.PENDING) return false;\n\n        const vertices = this.getVertices();\n        for (let i = 0; i < 2; i++) {\n            if (vertices[i].hasMaximumRemovedWalls()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    shouldNotBeRemoved() {\n        const endpoints = this.getVertices();\n        for (let i = 0; i < 2; i++) {\n            if (endpoints[i].shouldNotRemoveWalls()) return true;\n        }\n        return false;\n    }\n}\n\n\n/* harmony default export */ __webpack_exports__["b"] = (Wall);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy9XYWxsLmpzPzlkMDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE1hemVFbnRpdHkgZnJvbSAnLi9NYXplRW50aXR5LmpzJztcbmltcG9ydCBWZXJ0ZXggZnJvbSAnLi9WZXJ0ZXguanMnO1xuXG5jb25zdCBXYWxsU3RhdGUgPSB7XG4gICAgUEVORElORzogJ1BFTkRJTkcnLFxuICAgIENPTkZJUk1FRDogJ0NPTkZJUk1FRCcsXG4gICAgUkVNT1ZFRDogJ1JFTU9WRUQnXG59XG5cbmNsYXNzIFdhbGwgZXh0ZW5kcyBNYXplRW50aXR5IHtcbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSAoXG4gICAgICAgICAgICAgICAgdGhpcy5yb3cgPT09IDAgfHwgdGhpcy5yb3cgPT09IHRoaXMubWF6ZS5yb3dzKjIgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmNvbCA9PT0gMCB8fCB0aGlzLmNvbCA9PT0gdGhpcy5tYXplLmNvbHMqMlxuICAgICAgICAgICAgKSA/IFdhbGxTdGF0ZS5DT05GSVJNRUQgOiBXYWxsU3RhdGUuUEVORElORztcbiAgICB9XG5cbiAgICBnZXRWZXJ0aWNlcygpIHtcbiAgICAgICAgY29uc3QgbmVpZ2hib3JzID0gdGhpcy5nZXRMaXN0T2ZOZWlnaGJvcnNBdERpc3QoMSk7XG4gICAgICAgIGNvbnN0IHZlcnRpY2VzID0gbmVpZ2hib3JzLmZpbHRlcigobmVpZ2hib3IpID0+IG5laWdoYm9yIGluc3RhbmNlb2YgVmVydGV4KTtcbiAgICAgICAgcmV0dXJuIHZlcnRpY2VzO1xuICAgIH1cblxuICAgIGlzUmVtb3ZhYmxlKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gV2FsbFN0YXRlLlBFTkRJTkcpIHJldHVybiBmYWxzZTtcblxuICAgICAgICBjb25zdCB2ZXJ0aWNlcyA9IHRoaXMuZ2V0VmVydGljZXMoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh2ZXJ0aWNlc1tpXS5oYXNNYXhpbXVtUmVtb3ZlZFdhbGxzKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgc2hvdWxkTm90QmVSZW1vdmVkKCkge1xuICAgICAgICBjb25zdCBlbmRwb2ludHMgPSB0aGlzLmdldFZlcnRpY2VzKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZW5kcG9pbnRzW2ldLnNob3VsZE5vdFJlbW92ZVdhbGxzKCkpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmV4cG9ydCB7V2FsbFN0YXRlfVxuZXhwb3J0IGRlZmF1bHQgV2FsbFxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return initUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return randInt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return getDeviceType; });\nfunction initUtils() {\n    Array.prototype.shuffle = function() {\n        for (let i = this.length - 1; i > 0; i--) {\n            const j = Math.floor(Math.random() * (i + 1));\n            [this[i], this[j]] = [this[j], this[i]];\n        }\n        return this;\n    }\n\n    $.fn.extend({\n        disable: function () {\n            $(this)\n                .attr('disabled', true)\n                .addClass('disabled')\n                .find('input').attr('disabled', true);\n        },\n        enable: function() {\n            $(this)\n                .attr('disabled', false)\n                .removeClass('disabled')\n                .find('input').attr('disabled', false);\n        }\n    });\n}\n\n// Min inclusive, max inclusive\nfunction randInt(min, max) {\n  return Math.floor(Math.random() * (max + 1 - min) ) + min;\n}\n\n// Returns true for mobile devices.\nfunction getDeviceType() {\n    let isMobile = false;\n    (function(a){if(/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(a.substr(0,4))) isMobile = true;})(navigator.userAgent||navigator.vendor||window.opera);\n    return isMobile;\n};\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(4)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy91dGlscy5qcz85OTQ0Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGluaXRVdGlscygpIHtcbiAgICBBcnJheS5wcm90b3R5cGUuc2h1ZmZsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBqID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGkgKyAxKSk7XG4gICAgICAgICAgICBbdGhpc1tpXSwgdGhpc1tqXV0gPSBbdGhpc1tqXSwgdGhpc1tpXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgJC5mbi5leHRlbmQoe1xuICAgICAgICBkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkKHRoaXMpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2Rpc2FibGVkJywgdHJ1ZSlcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2Rpc2FibGVkJylcbiAgICAgICAgICAgICAgICAuZmluZCgnaW5wdXQnKS5hdHRyKCdkaXNhYmxlZCcsIHRydWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbmFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJCh0aGlzKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdkaXNhYmxlZCcsIGZhbHNlKVxuICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcygnZGlzYWJsZWQnKVxuICAgICAgICAgICAgICAgIC5maW5kKCdpbnB1dCcpLmF0dHIoJ2Rpc2FibGVkJywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbi8vIE1pbiBpbmNsdXNpdmUsIG1heCBpbmNsdXNpdmVcbmZ1bmN0aW9uIHJhbmRJbnQobWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggKyAxIC0gbWluKSApICsgbWluO1xufVxuXG4vLyBSZXR1cm5zIHRydWUgZm9yIG1vYmlsZSBkZXZpY2VzLlxuZnVuY3Rpb24gZ2V0RGV2aWNlVHlwZSgpIHtcbiAgICBsZXQgaXNNb2JpbGUgPSBmYWxzZTtcbiAgICAoZnVuY3Rpb24oYSl7aWYoLyhhbmRyb2lkfGJiXFxkK3xtZWVnbykuK21vYmlsZXxhdmFudGdvfGJhZGFcXC98YmxhY2tiZXJyeXxibGF6ZXJ8Y29tcGFsfGVsYWluZXxmZW5uZWN8aGlwdG9wfGllbW9iaWxlfGlwKGhvbmV8b2QpfGlyaXN8a2luZGxlfGxnZSB8bWFlbW98bWlkcHxtbXB8bW9iaWxlLitmaXJlZm94fG5ldGZyb250fG9wZXJhIG0ob2J8aW4paXxwYWxtKCBvcyk/fHBob25lfHAoaXhpfHJlKVxcL3xwbHVja2VyfHBvY2tldHxwc3B8c2VyaWVzKDR8NikwfHN5bWJpYW58dHJlb3x1cFxcLihicm93c2VyfGxpbmspfHZvZGFmb25lfHdhcHx3aW5kb3dzIGNlfHhkYXx4aWluby9pLnRlc3QoYSl8fC8xMjA3fDYzMTB8NjU5MHwzZ3NvfDR0aHB8NTBbMS02XWl8Nzcwc3w4MDJzfGEgd2F8YWJhY3xhYyhlcnxvb3xzXFwtKXxhaShrb3xybil8YWwoYXZ8Y2F8Y28pfGFtb2l8YW4oZXh8bnl8eXcpfGFwdHV8YXIoY2h8Z28pfGFzKHRlfHVzKXxhdHR3fGF1KGRpfFxcLW18ciB8cyApfGF2YW58YmUoY2t8bGx8bnEpfGJpKGxifHJkKXxibChhY3xheil8YnIoZXx2KXd8YnVtYnxid1xcLShufHUpfGM1NVxcL3xjYXBpfGNjd2F8Y2RtXFwtfGNlbGx8Y2h0bXxjbGRjfGNtZFxcLXxjbyhtcHxuZCl8Y3Jhd3xkYShpdHxsbHxuZyl8ZGJ0ZXxkY1xcLXN8ZGV2aXxkaWNhfGRtb2J8ZG8oY3xwKW98ZHMoMTJ8XFwtZCl8ZWwoNDl8YWkpfGVtKGwyfHVsKXxlcihpY3xrMCl8ZXNsOHxleihbNC03XTB8b3N8d2F8emUpfGZldGN8Zmx5KFxcLXxfKXxnMSB1fGc1NjB8Z2VuZXxnZlxcLTV8Z1xcLW1vfGdvKFxcLnd8b2QpfGdyKGFkfHVuKXxoYWllfGhjaXR8aGRcXC0obXxwfHQpfGhlaVxcLXxoaShwdHx0YSl8aHAoIGl8aXApfGhzXFwtY3xodChjKFxcLXwgfF98YXxnfHB8c3x0KXx0cCl8aHUoYXd8dGMpfGlcXC0oMjB8Z298bWEpfGkyMzB8aWFjKCB8XFwtfFxcLyl8aWJyb3xpZGVhfGlnMDF8aWtvbXxpbTFrfGlubm98aXBhcXxpcmlzfGphKHR8dilhfGpicm98amVtdXxqaWdzfGtkZGl8a2VqaXxrZ3QoIHxcXC8pfGtsb258a3B0IHxrd2NcXC18a3lvKGN8ayl8bGUobm98eGkpfGxnKCBnfFxcLyhrfGx8dSl8NTB8NTR8XFwtW2Etd10pfGxpYnd8bHlueHxtMVxcLXd8bTNnYXxtNTBcXC98bWEodGV8dWl8eG8pfG1jKDAxfDIxfGNhKXxtXFwtY3J8bWUocmN8cmkpfG1pKG84fG9hfHRzKXxtbWVmfG1vKDAxfDAyfGJpfGRlfGRvfHQoXFwtfCB8b3x2KXx6eil8bXQoNTB8cDF8diApfG13YnB8bXl3YXxuMTBbMC0yXXxuMjBbMi0zXXxuMzAoMHwyKXxuNTAoMHwyfDUpfG43KDAoMHwxKXwxMCl8bmUoKGN8bSlcXC18b258dGZ8d2Z8d2d8d3QpfG5vayg2fGkpfG56cGh8bzJpbXxvcCh0aXx3dil8b3Jhbnxvd2cxfHA4MDB8cGFuKGF8ZHx0KXxwZHhnfHBnKDEzfFxcLShbMS04XXxjKSl8cGhpbHxwaXJlfHBsKGF5fHVjKXxwblxcLTJ8cG8oY2t8cnR8c2UpfHByb3h8cHNpb3xwdFxcLWd8cWFcXC1hfHFjKDA3fDEyfDIxfDMyfDYwfFxcLVsyLTddfGlcXC0pfHF0ZWt8cjM4MHxyNjAwfHJha3N8cmltOXxybyh2ZXx6byl8czU1XFwvfHNhKGdlfG1hfG1tfG1zfG55fHZhKXxzYygwMXxoXFwtfG9vfHBcXC0pfHNka1xcL3xzZShjKFxcLXwwfDEpfDQ3fG1jfG5kfHJpKXxzZ2hcXC18c2hhcnxzaWUoXFwtfG0pfHNrXFwtMHxzbCg0NXxpZCl8c20oYWx8YXJ8YjN8aXR8dDUpfHNvKGZ0fG55KXxzcCgwMXxoXFwtfHZcXC18diApfHN5KDAxfG1iKXx0MigxOHw1MCl8dDYoMDB8MTB8MTgpfHRhKGd0fGxrKXx0Y2xcXC18dGRnXFwtfHRlbChpfG0pfHRpbVxcLXx0XFwtbW98dG8ocGx8c2gpfHRzKDcwfG1cXC18bTN8bTUpfHR4XFwtOXx1cChcXC5ifGcxfHNpKXx1dHN0fHY0MDB8djc1MHx2ZXJpfHZpKHJnfHRlKXx2ayg0MHw1WzAtM118XFwtdil8dm00MHx2b2RhfHZ1bGN8dngoNTJ8NTN8NjB8NjF8NzB8ODB8ODF8ODN8ODV8OTgpfHczYyhcXC18ICl8d2ViY3x3aGl0fHdpKGcgfG5jfG53KXx3bWxifHdvbnV8eDcwMHx5YXNcXC18eW91cnx6ZXRvfHp0ZVxcLS9pLnRlc3QoYS5zdWJzdHIoMCw0KSkpIGlzTW9iaWxlID0gdHJ1ZTt9KShuYXZpZ2F0b3IudXNlckFnZW50fHxuYXZpZ2F0b3IudmVuZG9yfHx3aW5kb3cub3BlcmEpO1xuICAgIHJldHVybiBpc01vYmlsZTtcbn07XG5cbmV4cG9ydCB7aW5pdFV0aWxzLCByYW5kSW50LCBnZXREZXZpY2VUeXBlfTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("class MazeEntity {\n    constructor(maze, row, col) {\n        Object.assign(this, {maze, row, col});\n    }\n\n    /**\n     * Override toString to ensure unique key for object in hashtable.\n     */\n    toString() {\n        return `${this.constructor.name}_${this.row}_${this.col}`;\n    }\n\n    getDictOfNeighborsAtDist(distance) {\n        const data = this.maze.data, row = this.row, col = this.col;\n        return {\n            'left': col > (distance - 1) ? data[row][col - distance] : null,\n            'right': col < data[0].length - distance ? data[row][col + distance] : null,\n            'top': row > (distance - 1) ? data[row - distance][col] : null,\n            'bottom': row < data.length - distance ? data[row + distance][col] : null\n        }\n    }\n\n    getListOfNeighborsAtDist(distance) {\n        return Object.values(this.getDictOfNeighborsAtDist(distance)).filter((x) => x !== null)\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (MazeEntity);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy9NYXplRW50aXR5LmpzP2E4YjEiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgTWF6ZUVudGl0eSB7XG4gICAgY29uc3RydWN0b3IobWF6ZSwgcm93LCBjb2wpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7bWF6ZSwgcm93LCBjb2x9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0b1N0cmluZyB0byBlbnN1cmUgdW5pcXVlIGtleSBmb3Igb2JqZWN0IGluIGhhc2h0YWJsZS5cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuY29uc3RydWN0b3IubmFtZX1fJHt0aGlzLnJvd31fJHt0aGlzLmNvbH1gO1xuICAgIH1cblxuICAgIGdldERpY3RPZk5laWdoYm9yc0F0RGlzdChkaXN0YW5jZSkge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5tYXplLmRhdGEsIHJvdyA9IHRoaXMucm93LCBjb2wgPSB0aGlzLmNvbDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdsZWZ0JzogY29sID4gKGRpc3RhbmNlIC0gMSkgPyBkYXRhW3Jvd11bY29sIC0gZGlzdGFuY2VdIDogbnVsbCxcbiAgICAgICAgICAgICdyaWdodCc6IGNvbCA8IGRhdGFbMF0ubGVuZ3RoIC0gZGlzdGFuY2UgPyBkYXRhW3Jvd11bY29sICsgZGlzdGFuY2VdIDogbnVsbCxcbiAgICAgICAgICAgICd0b3AnOiByb3cgPiAoZGlzdGFuY2UgLSAxKSA/IGRhdGFbcm93IC0gZGlzdGFuY2VdW2NvbF0gOiBudWxsLFxuICAgICAgICAgICAgJ2JvdHRvbSc6IHJvdyA8IGRhdGEubGVuZ3RoIC0gZGlzdGFuY2UgPyBkYXRhW3JvdyArIGRpc3RhbmNlXVtjb2xdIDogbnVsbFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0TGlzdE9mTmVpZ2hib3JzQXREaXN0KGRpc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuZ2V0RGljdE9mTmVpZ2hib3JzQXREaXN0KGRpc3RhbmNlKSkuZmlsdGVyKCh4KSA9PiB4ICE9PSBudWxsKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTWF6ZUVudGl0eTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _MazeEntity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var _Wall_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);\n\n\n\nclass Vertex extends _MazeEntity_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"] {\n    constructor(...args) {\n        super(...args);\n    }\n\n    getOutgoingWalls() {\n        return this.getListOfNeighborsAtDist(1)\n    }\n\n    // The maximum number of outgoing walls a vertex can have in the REMOVED\n    // state is 3.\n    hasMaximumRemovedWalls() {\n        return this.getOutgoingWalls()\n            .filter((wall) => wall.state === _Wall_js__WEBPACK_IMPORTED_MODULE_1__[/* WallState */ "a"].REMOVED)\n            .length >= 3\n    }\n\n    // Call this function on both endpoints, when considering whether to remove a PENDING wall.\n    // It is a recommendation, rather than a hard rule.\n    shouldNotRemoveWalls() {\n        const walls = this.getOutgoingWalls();\n        const confirmedWalls = walls.filter((wall) => wall.state === _Wall_js__WEBPACK_IMPORTED_MODULE_1__[/* WallState */ "a"].CONFIRMED);\n        const pendingWalls = walls.filter((wall) => wall.state === _Wall_js__WEBPACK_IMPORTED_MODULE_1__[/* WallState */ "a"].PENDING);\n\n        // If at least 2 confirmed walls, there can\'t be a lone wall.\n        // If 0, it\'s possible there could be a lone wall later down the road...\n        if (confirmedWalls.length !== 1) return false;\n\n        // If another wall which *could* be confirmed in the future, we\'re safe for now.\n        if (pendingWalls.length > 1) return false;\n\n        const wall = confirmedWalls[0];\n        const vertices = wall.getVertices();\n\n        // Get vertex at other end of wall.\n        for (let i = 0; i < 2; i++) {\n            const vertex = vertices[i];\n            if (vertex === this) continue;\n\n            // Check whether wall is (or could be) supported at its other vertex.\n            const removedWalls = vertex.getOutgoingWalls().filter((wall) => wall.state === _Wall_js__WEBPACK_IMPORTED_MODULE_1__[/* WallState */ "a"].REMOVED);\n            if (removedWalls.length === 3) return true;\n        }\n\n        return false;\n    }\n}\n\n/* harmony default export */ __webpack_exports__["a"] = (Vertex);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy9WZXJ0ZXguanM/NDg3OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTWF6ZUVudGl0eSBmcm9tICcuL01hemVFbnRpdHkuanMnO1xuaW1wb3J0IHtXYWxsU3RhdGV9IGZyb20gJy4vV2FsbC5qcydcblxuY2xhc3MgVmVydGV4IGV4dGVuZHMgTWF6ZUVudGl0eSB7XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICB9XG5cbiAgICBnZXRPdXRnb2luZ1dhbGxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMaXN0T2ZOZWlnaGJvcnNBdERpc3QoMSlcbiAgICB9XG5cbiAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2Ygb3V0Z29pbmcgd2FsbHMgYSB2ZXJ0ZXggY2FuIGhhdmUgaW4gdGhlIFJFTU9WRURcbiAgICAvLyBzdGF0ZSBpcyAzLlxuICAgIGhhc01heGltdW1SZW1vdmVkV2FsbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE91dGdvaW5nV2FsbHMoKVxuICAgICAgICAgICAgLmZpbHRlcigod2FsbCkgPT4gd2FsbC5zdGF0ZSA9PT0gV2FsbFN0YXRlLlJFTU9WRUQpXG4gICAgICAgICAgICAubGVuZ3RoID49IDNcbiAgICB9XG5cbiAgICAvLyBDYWxsIHRoaXMgZnVuY3Rpb24gb24gYm90aCBlbmRwb2ludHMsIHdoZW4gY29uc2lkZXJpbmcgd2hldGhlciB0byByZW1vdmUgYSBQRU5ESU5HIHdhbGwuXG4gICAgLy8gSXQgaXMgYSByZWNvbW1lbmRhdGlvbiwgcmF0aGVyIHRoYW4gYSBoYXJkIHJ1bGUuXG4gICAgc2hvdWxkTm90UmVtb3ZlV2FsbHMoKSB7XG4gICAgICAgIGNvbnN0IHdhbGxzID0gdGhpcy5nZXRPdXRnb2luZ1dhbGxzKCk7XG4gICAgICAgIGNvbnN0IGNvbmZpcm1lZFdhbGxzID0gd2FsbHMuZmlsdGVyKCh3YWxsKSA9PiB3YWxsLnN0YXRlID09PSBXYWxsU3RhdGUuQ09ORklSTUVEKTtcbiAgICAgICAgY29uc3QgcGVuZGluZ1dhbGxzID0gd2FsbHMuZmlsdGVyKCh3YWxsKSA9PiB3YWxsLnN0YXRlID09PSBXYWxsU3RhdGUuUEVORElORyk7XG5cbiAgICAgICAgLy8gSWYgYXQgbGVhc3QgMiBjb25maXJtZWQgd2FsbHMsIHRoZXJlIGNhbid0IGJlIGEgbG9uZSB3YWxsLlxuICAgICAgICAvLyBJZiAwLCBpdCdzIHBvc3NpYmxlIHRoZXJlIGNvdWxkIGJlIGEgbG9uZSB3YWxsIGxhdGVyIGRvd24gdGhlIHJvYWQuLi5cbiAgICAgICAgaWYgKGNvbmZpcm1lZFdhbGxzLmxlbmd0aCAhPT0gMSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIC8vIElmIGFub3RoZXIgd2FsbCB3aGljaCAqY291bGQqIGJlIGNvbmZpcm1lZCBpbiB0aGUgZnV0dXJlLCB3ZSdyZSBzYWZlIGZvciBub3cuXG4gICAgICAgIGlmIChwZW5kaW5nV2FsbHMubGVuZ3RoID4gMSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGNvbnN0IHdhbGwgPSBjb25maXJtZWRXYWxsc1swXTtcbiAgICAgICAgY29uc3QgdmVydGljZXMgPSB3YWxsLmdldFZlcnRpY2VzKCk7XG5cbiAgICAgICAgLy8gR2V0IHZlcnRleCBhdCBvdGhlciBlbmQgb2Ygd2FsbC5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHZlcnRleCA9IHZlcnRpY2VzW2ldO1xuICAgICAgICAgICAgaWYgKHZlcnRleCA9PT0gdGhpcykgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgd2FsbCBpcyAob3IgY291bGQgYmUpIHN1cHBvcnRlZCBhdCBpdHMgb3RoZXIgdmVydGV4LlxuICAgICAgICAgICAgY29uc3QgcmVtb3ZlZFdhbGxzID0gdmVydGV4LmdldE91dGdvaW5nV2FsbHMoKS5maWx0ZXIoKHdhbGwpID0+IHdhbGwuc3RhdGUgPT09IFdhbGxTdGF0ZS5SRU1PVkVEKTtcbiAgICAgICAgICAgIGlmIChyZW1vdmVkV2FsbHMubGVuZ3RoID09PSAzKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFZlcnRleDtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3\n')},function(module,exports){eval("module.exports = jQuery;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcImpRdWVyeVwiP2NkMGMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBqUXVlcnk7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// EXTERNAL MODULE: ./src/js/utils.js\nvar utils = __webpack_require__(1);\n\n// EXTERNAL MODULE: ./src/js/MazeEntity.js\nvar MazeEntity = __webpack_require__(2);\n\n// EXTERNAL MODULE: ./src/js/Wall.js\nvar Wall = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./src/js/Cell.js\n\n\n\n\nclass Cell_Group {\n    constructor(cell) {\n        this.accessibleUnvisitedCells = new Set([cell]);\n        this.memberCells = [cell];\n        this.color = `rgb(${Object(utils["c" /* randInt */])(0,255)}, ${Object(utils["c" /* randInt */])(0,255)}, ${Object(utils["c" /* randInt */])(0,255)})`;\n    }\n\n    mergeWithGroup(group) {\n        const [deprecatedGroup, persistingGroup] = [this, group].sort((a,b) => a.memberCells.length > b.memberCells.length ? 1 : -1);\n        deprecatedGroup.memberCells.forEach((cell) => cell.group = persistingGroup);\n        persistingGroup.memberCells = persistingGroup.memberCells.concat(deprecatedGroup.memberCells);\n    }\n}\n\nclass Cell_Cell extends MazeEntity["a" /* default */] {\n    constructor(...args) {\n        super(...args);\n\n        this.group = new Cell_Group(this);\n        this.visited = false;\n    }\n\n    /**\n     * @returns {Array.<Cell>} List of neighboring cells\n     */\n    getNeighboringCells() {\n        return this.getListOfNeighborsAtDist(2)\n    }\n\n    /**\n     * @param {Cell} cell\n     * @returns {boolean} Represents whether there is a removed wall between cells\n     */\n\n    canAccessCell(cell) {\n        return (\n            this.isNeighboringCell(cell)\n            && this.getInterveningWall(cell).state === Wall["a" /* WallState */].REMOVED\n        )\n    }\n\n    getInterveningWall(cell) {\n        if (this.isNeighboringCell(cell)) {\n            return this.maze.data[(this.row + cell.row) / 2][(this.col + cell.col) / 2]\n        }\n        return null;\n    }\n\n    isNeighboringCell(cell) {\n        return this.getNeighboringCells().includes(cell);\n    }\n\n    /**\n     * @returns {Array.<Cell>} List of neighboring cells that are accessible\n     */\n    getAccessibleNeighbors() {\n        return this.getNeighboringCells().filter((c) => this.canAccessCell(c))\n    }\n\n    getUniqueNeighboringGroups(onlyVisited) {\n        let accessibleNeighbors = this.getAccessibleNeighbors()\n        if (onlyVisited) accessibleNeighbors = accessibleNeighbors.filter((neighbor) => neighbor.visited)\n\n        return accessibleNeighbors.reduce((acc, neighbor)=>{\n            return acc.includes(neighbor.group) ? acc : acc.concat([neighbor.group])\n        }, []);\n    }\n\n    /**\n     * @returns {Object} Dictionary of walls surrounding this cell\n     */\n    getWalls() {\n        return this.getDictOfNeighborsAtDist(1)\n    }\n\n    removeAtLeastNWalls(minimumWallsToRemove){\n        const walls = Object.values(this.getWalls()).shuffle();\n\n        // Move walls that shouldn\'t be removed later in list, to decrease chance of removal.\n        walls.sort((a, b) => a.shouldNotBeRemoved() && !b.shouldNotBeRemoved() ? 1 : -1);\n\n        const removableWalls = walls.filter((wall)=>wall.isRemovable())\n        const numberOfWallsToRemove = Object(utils["c" /* randInt */])(minimumWallsToRemove, removableWalls.length);\n\n        let removedWalls = 0;\n        walls.forEach((wall)=>{\n            if(wall.state==Wall["a" /* WallState */].PENDING){\n                if (removableWalls.includes(wall) && removedWalls < numberOfWallsToRemove) {\n                    if (wall.shouldNotBeRemoved() && removedWalls > minimumWallsToRemove) {\n                        wall.state = Wall["a" /* WallState */].CONFIRMED;\n                        return;\n                    }\n                    wall.state = Wall["a" /* WallState */].REMOVED;\n                    removedWalls++;\n                } else {\n                    wall.state = Wall["a" /* WallState */].CONFIRMED\n                }\n            }\n        });\n    }\n\n    visit() {\n        // Get the groups that will be merged with this cell. For each one,\n        // this cell no longer counts as an "accessible unvisited cell", so\n        // delete it from their records.\n        let neighboringGroups = this.getUniqueNeighboringGroups();\n        neighboringGroups.forEach(\n                (group)=> group.accessibleUnvisitedCells.delete(this)\n        )\n\n        // If the merged group which includes this cell already has access to\n        // a least one unvisited cell, then we don\'t need to remove any walls.\n        // If it does NOT have access to at least one unvisited cell, we need\n        // to maintain access by deleting at least one wall.\n        const minWallsToRemove =\n            getAllAccessibleUnvisitedCells(neighboringGroups).size ? 0 : 1;\n\n        // Remove at least the specified number of walls.\n        this.removeAtLeastNWalls(minWallsToRemove)\n\n        // Now that we\'ve removed some walls, re-calculate the neighboring\n        // groups to include those that we have just gained access to.\n        // Once we merge, we\'ll want the newly merged group to count, among its\n        // "accessible unvisited cells", anything accessible via these neighboring\n        // groups\n        neighboringGroups = this.getUniqueNeighboringGroups();\n        const newAllUnvisited = getAllAccessibleUnvisitedCells(neighboringGroups)\n\n        // Perform the merge & update the "accessible unvisited cells"\n        this.getUniqueNeighboringGroups(true)\n            .forEach((group) => this.group.mergeWithGroup(group));\n        this.group.accessibleUnvisitedCells = newAllUnvisited;\n\n        // Mark this cell as visited\n        this.visited = true;\n    }\n\n}\n\nfunction getAllAccessibleUnvisitedCells(groups){\n    const allUnvisitedCells = new Set();\n    groups.forEach((group) => {\n        group.accessibleUnvisitedCells.forEach((cell)=>{\n            allUnvisitedCells.add(cell)\n        })\n    });\n    return allUnvisitedCells;\n}\n\n/* harmony default export */ var js_Cell = (Cell_Cell);\n\n// EXTERNAL MODULE: ./src/js/Vertex.js\nvar Vertex = __webpack_require__(3);\n\n// CONCATENATED MODULE: ./src/js/Maze.js\n\n\n\n\n\nclass Maze_Maze {\n    constructor(rows, cols) {\n        this.rows = rows;\n        this.cols = cols;\n        this.data = [];\n        this.visitedCellsCount = 0;\n\n        const dataTypes = [\n            [Vertex["a" /* default */], Wall["b" /* default */]],\n            [Wall["b" /* default */], js_Cell]\n        ];\n\n        for (let r = 0; r < 2*rows+1; r++) {\n            const row = [];\n            for (let c = 0; c < 2*cols+1; c++) {\n                // Initialize each entity with its coordinates and a reference to the maze.\n                row.push(new dataTypes[r%2][c%2](this, r, c));\n            }\n            this.data.push(row);\n        }\n    }\n\n    getCells() {\n        return this.data.reduce((cells, row) => {\n            return cells.concat(row.filter((entity) => entity instanceof js_Cell));\n        }, []);\n    }\n\n    generateMaze() {\n        if (this.visitedCellsCount > 0) return;\n        while (this.generateNextCell()) {}\n    }\n\n    generateNextCell() {\n        const cells = this.getCells();\n        if (this.visitedCellsCount === cells.length) return false;\n\n        const cell = cells[this.visitedCellsCount];\n        cell.visit();\n        this.visitedCellsCount++;\n\n        return true;\n    }\n\n    /**\n     * Generic implementation of breadth-first search. Returns nothing, but exposes\n     * customizable functionality via callback function.\n     *\n     * @param {Cell} startCell - Cell to begin searching outwards from.\n     * @param {Function} callback - Takes parent Cell, followed by its child Cell.\n     */\n    breadthFirstSearch(startCell, callback) {\n        const distanceDict = {};\n        const visitedCells = new Set([startCell]);\n\n        let frontierCells = [startCell];\n\n        while (frontierCells.length) {\n            const newFrontier = [];\n            frontierCells.forEach((cell) => {\n                const accessibleNeighbors = cell.getAccessibleNeighbors();\n                const unvisitedAccessible = accessibleNeighbors.filter((neighbor) => !visitedCells.has(neighbor));\n\n                unvisitedAccessible.forEach((unvisited) => {\n                    callback(cell, unvisited)\n                    newFrontier.push(unvisited);\n                    visitedCells.add(unvisited);\n                });\n            });\n            frontierCells = newFrontier;\n        }\n    }\n\n    /**\n     * Calculate distance of all maze cells from cell at given index,\n     * then use color to visualize distance.\n     *\n     * @param {number} startIdx - Index of selected start cell.\n     * @returns {Object.<Cell, number>} Dictionary of distances from start cell.\n     */\n    getDistanceDict(startIdx){\n        const startCell = this.getCells()[startIdx];\n        const distanceDict = {}\n        distanceDict[startCell] = 0;\n\n        this.breadthFirstSearch(startCell, (parent, child)=>{\n            distanceDict[child] = distanceDict[parent] + 1;\n        });\n\n        return distanceDict;\n    }\n\n    /**\n     * Uses breadth-first search to find the shortest path between two cells.\n     *\n     * @param {number} startIdx - Index of start cell.\n     * @param {number} endIdx - Index of end cell.\n     * @returns {Array} List of cells in shortest path (including start and end cell).\n     */\n    getShortestPathData(startIdx, endIdx){\n        const cells = this.getCells();\n        const startCell = cells[startIdx];\n        const endCell = cells[endIdx];\n\n        const previousDict = {}\n        previousDict[startCell] = null;\n\n        this.breadthFirstSearch(startCell, (parent, child) => {\n            previousDict[child] = parent;\n        });\n\n        const path = [];\n\n        let prevCell = endCell;\n        while (prevCell !== null) {\n            path.unshift(prevCell)\n            prevCell = previousDict[prevCell];\n        }\n\n        return path;\n    }\n}\n\n/* harmony default export */ var js_Maze = __webpack_exports__["a"] = (Maze_Maze);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy9DZWxsLmpzPzYxYTEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL01hemUuanM/NDQ2OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3JhbmRJbnR9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IE1hemVFbnRpdHkgZnJvbSAnLi9NYXplRW50aXR5LmpzJztcbmltcG9ydCB7V2FsbFN0YXRlfSBmcm9tICcuL1dhbGwuanMnXG5cbmNsYXNzIEdyb3VwIHtcbiAgICBjb25zdHJ1Y3RvcihjZWxsKSB7XG4gICAgICAgIHRoaXMuYWNjZXNzaWJsZVVudmlzaXRlZENlbGxzID0gbmV3IFNldChbY2VsbF0pO1xuICAgICAgICB0aGlzLm1lbWJlckNlbGxzID0gW2NlbGxdO1xuICAgICAgICB0aGlzLmNvbG9yID0gYHJnYigke3JhbmRJbnQoMCwyNTUpfSwgJHtyYW5kSW50KDAsMjU1KX0sICR7cmFuZEludCgwLDI1NSl9KWA7XG4gICAgfVxuXG4gICAgbWVyZ2VXaXRoR3JvdXAoZ3JvdXApIHtcbiAgICAgICAgY29uc3QgW2RlcHJlY2F0ZWRHcm91cCwgcGVyc2lzdGluZ0dyb3VwXSA9IFt0aGlzLCBncm91cF0uc29ydCgoYSxiKSA9PiBhLm1lbWJlckNlbGxzLmxlbmd0aCA+IGIubWVtYmVyQ2VsbHMubGVuZ3RoID8gMSA6IC0xKTtcbiAgICAgICAgZGVwcmVjYXRlZEdyb3VwLm1lbWJlckNlbGxzLmZvckVhY2goKGNlbGwpID0+IGNlbGwuZ3JvdXAgPSBwZXJzaXN0aW5nR3JvdXApO1xuICAgICAgICBwZXJzaXN0aW5nR3JvdXAubWVtYmVyQ2VsbHMgPSBwZXJzaXN0aW5nR3JvdXAubWVtYmVyQ2VsbHMuY29uY2F0KGRlcHJlY2F0ZWRHcm91cC5tZW1iZXJDZWxscyk7XG4gICAgfVxufVxuXG5jbGFzcyBDZWxsIGV4dGVuZHMgTWF6ZUVudGl0eSB7XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcblxuICAgICAgICB0aGlzLmdyb3VwID0gbmV3IEdyb3VwKHRoaXMpO1xuICAgICAgICB0aGlzLnZpc2l0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPENlbGw+fSBMaXN0IG9mIG5laWdoYm9yaW5nIGNlbGxzXG4gICAgICovXG4gICAgZ2V0TmVpZ2hib3JpbmdDZWxscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGlzdE9mTmVpZ2hib3JzQXREaXN0KDIpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDZWxsfSBjZWxsXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJlcHJlc2VudHMgd2hldGhlciB0aGVyZSBpcyBhIHJlbW92ZWQgd2FsbCBiZXR3ZWVuIGNlbGxzXG4gICAgICovXG5cbiAgICBjYW5BY2Nlc3NDZWxsKGNlbGwpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuaXNOZWlnaGJvcmluZ0NlbGwoY2VsbClcbiAgICAgICAgICAgICYmIHRoaXMuZ2V0SW50ZXJ2ZW5pbmdXYWxsKGNlbGwpLnN0YXRlID09PSBXYWxsU3RhdGUuUkVNT1ZFRFxuICAgICAgICApXG4gICAgfVxuXG4gICAgZ2V0SW50ZXJ2ZW5pbmdXYWxsKGNlbGwpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNOZWlnaGJvcmluZ0NlbGwoY2VsbCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hemUuZGF0YVsodGhpcy5yb3cgKyBjZWxsLnJvdykgLyAyXVsodGhpcy5jb2wgKyBjZWxsLmNvbCkgLyAyXVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlzTmVpZ2hib3JpbmdDZWxsKGNlbGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TmVpZ2hib3JpbmdDZWxscygpLmluY2x1ZGVzKGNlbGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48Q2VsbD59IExpc3Qgb2YgbmVpZ2hib3JpbmcgY2VsbHMgdGhhdCBhcmUgYWNjZXNzaWJsZVxuICAgICAqL1xuICAgIGdldEFjY2Vzc2libGVOZWlnaGJvcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE5laWdoYm9yaW5nQ2VsbHMoKS5maWx0ZXIoKGMpID0+IHRoaXMuY2FuQWNjZXNzQ2VsbChjKSlcbiAgICB9XG5cbiAgICBnZXRVbmlxdWVOZWlnaGJvcmluZ0dyb3Vwcyhvbmx5VmlzaXRlZCkge1xuICAgICAgICBsZXQgYWNjZXNzaWJsZU5laWdoYm9ycyA9IHRoaXMuZ2V0QWNjZXNzaWJsZU5laWdoYm9ycygpXG4gICAgICAgIGlmIChvbmx5VmlzaXRlZCkgYWNjZXNzaWJsZU5laWdoYm9ycyA9IGFjY2Vzc2libGVOZWlnaGJvcnMuZmlsdGVyKChuZWlnaGJvcikgPT4gbmVpZ2hib3IudmlzaXRlZClcblxuICAgICAgICByZXR1cm4gYWNjZXNzaWJsZU5laWdoYm9ycy5yZWR1Y2UoKGFjYywgbmVpZ2hib3IpPT57XG4gICAgICAgICAgICByZXR1cm4gYWNjLmluY2x1ZGVzKG5laWdoYm9yLmdyb3VwKSA/IGFjYyA6IGFjYy5jb25jYXQoW25laWdoYm9yLmdyb3VwXSlcbiAgICAgICAgfSwgW10pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IERpY3Rpb25hcnkgb2Ygd2FsbHMgc3Vycm91bmRpbmcgdGhpcyBjZWxsXG4gICAgICovXG4gICAgZ2V0V2FsbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldERpY3RPZk5laWdoYm9yc0F0RGlzdCgxKVxuICAgIH1cblxuICAgIHJlbW92ZUF0TGVhc3ROV2FsbHMobWluaW11bVdhbGxzVG9SZW1vdmUpe1xuICAgICAgICBjb25zdCB3YWxscyA9IE9iamVjdC52YWx1ZXModGhpcy5nZXRXYWxscygpKS5zaHVmZmxlKCk7XG5cbiAgICAgICAgLy8gTW92ZSB3YWxscyB0aGF0IHNob3VsZG4ndCBiZSByZW1vdmVkIGxhdGVyIGluIGxpc3QsIHRvIGRlY3JlYXNlIGNoYW5jZSBvZiByZW1vdmFsLlxuICAgICAgICB3YWxscy5zb3J0KChhLCBiKSA9PiBhLnNob3VsZE5vdEJlUmVtb3ZlZCgpICYmICFiLnNob3VsZE5vdEJlUmVtb3ZlZCgpID8gMSA6IC0xKTtcblxuICAgICAgICBjb25zdCByZW1vdmFibGVXYWxscyA9IHdhbGxzLmZpbHRlcigod2FsbCk9PndhbGwuaXNSZW1vdmFibGUoKSlcbiAgICAgICAgY29uc3QgbnVtYmVyT2ZXYWxsc1RvUmVtb3ZlID0gcmFuZEludChtaW5pbXVtV2FsbHNUb1JlbW92ZSwgcmVtb3ZhYmxlV2FsbHMubGVuZ3RoKTtcblxuICAgICAgICBsZXQgcmVtb3ZlZFdhbGxzID0gMDtcbiAgICAgICAgd2FsbHMuZm9yRWFjaCgod2FsbCk9PntcbiAgICAgICAgICAgIGlmKHdhbGwuc3RhdGU9PVdhbGxTdGF0ZS5QRU5ESU5HKXtcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZhYmxlV2FsbHMuaW5jbHVkZXMod2FsbCkgJiYgcmVtb3ZlZFdhbGxzIDwgbnVtYmVyT2ZXYWxsc1RvUmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3YWxsLnNob3VsZE5vdEJlUmVtb3ZlZCgpICYmIHJlbW92ZWRXYWxscyA+IG1pbmltdW1XYWxsc1RvUmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YWxsLnN0YXRlID0gV2FsbFN0YXRlLkNPTkZJUk1FRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3YWxsLnN0YXRlID0gV2FsbFN0YXRlLlJFTU9WRUQ7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWRXYWxscysrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdhbGwuc3RhdGUgPSBXYWxsU3RhdGUuQ09ORklSTUVEXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2aXNpdCgpIHtcbiAgICAgICAgLy8gR2V0IHRoZSBncm91cHMgdGhhdCB3aWxsIGJlIG1lcmdlZCB3aXRoIHRoaXMgY2VsbC4gRm9yIGVhY2ggb25lLFxuICAgICAgICAvLyB0aGlzIGNlbGwgbm8gbG9uZ2VyIGNvdW50cyBhcyBhbiBcImFjY2Vzc2libGUgdW52aXNpdGVkIGNlbGxcIiwgc29cbiAgICAgICAgLy8gZGVsZXRlIGl0IGZyb20gdGhlaXIgcmVjb3Jkcy5cbiAgICAgICAgbGV0IG5laWdoYm9yaW5nR3JvdXBzID0gdGhpcy5nZXRVbmlxdWVOZWlnaGJvcmluZ0dyb3VwcygpO1xuICAgICAgICBuZWlnaGJvcmluZ0dyb3Vwcy5mb3JFYWNoKFxuICAgICAgICAgICAgICAgIChncm91cCk9PiBncm91cC5hY2Nlc3NpYmxlVW52aXNpdGVkQ2VsbHMuZGVsZXRlKHRoaXMpXG4gICAgICAgIClcblxuICAgICAgICAvLyBJZiB0aGUgbWVyZ2VkIGdyb3VwIHdoaWNoIGluY2x1ZGVzIHRoaXMgY2VsbCBhbHJlYWR5IGhhcyBhY2Nlc3MgdG9cbiAgICAgICAgLy8gYSBsZWFzdCBvbmUgdW52aXNpdGVkIGNlbGwsIHRoZW4gd2UgZG9uJ3QgbmVlZCB0byByZW1vdmUgYW55IHdhbGxzLlxuICAgICAgICAvLyBJZiBpdCBkb2VzIE5PVCBoYXZlIGFjY2VzcyB0byBhdCBsZWFzdCBvbmUgdW52aXNpdGVkIGNlbGwsIHdlIG5lZWRcbiAgICAgICAgLy8gdG8gbWFpbnRhaW4gYWNjZXNzIGJ5IGRlbGV0aW5nIGF0IGxlYXN0IG9uZSB3YWxsLlxuICAgICAgICBjb25zdCBtaW5XYWxsc1RvUmVtb3ZlID1cbiAgICAgICAgICAgIGdldEFsbEFjY2Vzc2libGVVbnZpc2l0ZWRDZWxscyhuZWlnaGJvcmluZ0dyb3Vwcykuc2l6ZSA/IDAgOiAxO1xuXG4gICAgICAgIC8vIFJlbW92ZSBhdCBsZWFzdCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiB3YWxscy5cbiAgICAgICAgdGhpcy5yZW1vdmVBdExlYXN0TldhbGxzKG1pbldhbGxzVG9SZW1vdmUpXG5cbiAgICAgICAgLy8gTm93IHRoYXQgd2UndmUgcmVtb3ZlZCBzb21lIHdhbGxzLCByZS1jYWxjdWxhdGUgdGhlIG5laWdoYm9yaW5nXG4gICAgICAgIC8vIGdyb3VwcyB0byBpbmNsdWRlIHRob3NlIHRoYXQgd2UgaGF2ZSBqdXN0IGdhaW5lZCBhY2Nlc3MgdG8uXG4gICAgICAgIC8vIE9uY2Ugd2UgbWVyZ2UsIHdlJ2xsIHdhbnQgdGhlIG5ld2x5IG1lcmdlZCBncm91cCB0byBjb3VudCwgYW1vbmcgaXRzXG4gICAgICAgIC8vIFwiYWNjZXNzaWJsZSB1bnZpc2l0ZWQgY2VsbHNcIiwgYW55dGhpbmcgYWNjZXNzaWJsZSB2aWEgdGhlc2UgbmVpZ2hib3JpbmdcbiAgICAgICAgLy8gZ3JvdXBzXG4gICAgICAgIG5laWdoYm9yaW5nR3JvdXBzID0gdGhpcy5nZXRVbmlxdWVOZWlnaGJvcmluZ0dyb3VwcygpO1xuICAgICAgICBjb25zdCBuZXdBbGxVbnZpc2l0ZWQgPSBnZXRBbGxBY2Nlc3NpYmxlVW52aXNpdGVkQ2VsbHMobmVpZ2hib3JpbmdHcm91cHMpXG5cbiAgICAgICAgLy8gUGVyZm9ybSB0aGUgbWVyZ2UgJiB1cGRhdGUgdGhlIFwiYWNjZXNzaWJsZSB1bnZpc2l0ZWQgY2VsbHNcIlxuICAgICAgICB0aGlzLmdldFVuaXF1ZU5laWdoYm9yaW5nR3JvdXBzKHRydWUpXG4gICAgICAgICAgICAuZm9yRWFjaCgoZ3JvdXApID0+IHRoaXMuZ3JvdXAubWVyZ2VXaXRoR3JvdXAoZ3JvdXApKTtcbiAgICAgICAgdGhpcy5ncm91cC5hY2Nlc3NpYmxlVW52aXNpdGVkQ2VsbHMgPSBuZXdBbGxVbnZpc2l0ZWQ7XG5cbiAgICAgICAgLy8gTWFyayB0aGlzIGNlbGwgYXMgdmlzaXRlZFxuICAgICAgICB0aGlzLnZpc2l0ZWQgPSB0cnVlO1xuICAgIH1cblxufVxuXG5mdW5jdGlvbiBnZXRBbGxBY2Nlc3NpYmxlVW52aXNpdGVkQ2VsbHMoZ3JvdXBzKXtcbiAgICBjb25zdCBhbGxVbnZpc2l0ZWRDZWxscyA9IG5ldyBTZXQoKTtcbiAgICBncm91cHMuZm9yRWFjaCgoZ3JvdXApID0+IHtcbiAgICAgICAgZ3JvdXAuYWNjZXNzaWJsZVVudmlzaXRlZENlbGxzLmZvckVhY2goKGNlbGwpPT57XG4gICAgICAgICAgICBhbGxVbnZpc2l0ZWRDZWxscy5hZGQoY2VsbClcbiAgICAgICAgfSlcbiAgICB9KTtcbiAgICByZXR1cm4gYWxsVW52aXNpdGVkQ2VsbHM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IENlbGw7XG4iLCJpbXBvcnQgJy4vdXRpbHMuanMnO1xuaW1wb3J0IENlbGwgZnJvbSAnLi9DZWxsLmpzJztcbmltcG9ydCBXYWxsIGZyb20gJy4vV2FsbC5qcyc7XG5pbXBvcnQgVmVydGV4IGZyb20gJy4vVmVydGV4LmpzJztcblxuY2xhc3MgTWF6ZSB7XG4gICAgY29uc3RydWN0b3Iocm93cywgY29scykge1xuICAgICAgICB0aGlzLnJvd3MgPSByb3dzO1xuICAgICAgICB0aGlzLmNvbHMgPSBjb2xzO1xuICAgICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICAgICAgdGhpcy52aXNpdGVkQ2VsbHNDb3VudCA9IDA7XG5cbiAgICAgICAgY29uc3QgZGF0YVR5cGVzID0gW1xuICAgICAgICAgICAgW1ZlcnRleCwgV2FsbF0sXG4gICAgICAgICAgICBbV2FsbCwgQ2VsbF1cbiAgICAgICAgXTtcblxuICAgICAgICBmb3IgKGxldCByID0gMDsgciA8IDIqcm93cysxOyByKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCAyKmNvbHMrMTsgYysrKSB7XG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSBlYWNoIGVudGl0eSB3aXRoIGl0cyBjb29yZGluYXRlcyBhbmQgYSByZWZlcmVuY2UgdG8gdGhlIG1hemUuXG4gICAgICAgICAgICAgICAgcm93LnB1c2gobmV3IGRhdGFUeXBlc1tyJTJdW2MlMl0odGhpcywgciwgYykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kYXRhLnB1c2gocm93KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldENlbGxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnJlZHVjZSgoY2VsbHMsIHJvdykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNlbGxzLmNvbmNhdChyb3cuZmlsdGVyKChlbnRpdHkpID0+IGVudGl0eSBpbnN0YW5jZW9mIENlbGwpKTtcbiAgICAgICAgfSwgW10pO1xuICAgIH1cblxuICAgIGdlbmVyYXRlTWF6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudmlzaXRlZENlbGxzQ291bnQgPiAwKSByZXR1cm47XG4gICAgICAgIHdoaWxlICh0aGlzLmdlbmVyYXRlTmV4dENlbGwoKSkge31cbiAgICB9XG5cbiAgICBnZW5lcmF0ZU5leHRDZWxsKCkge1xuICAgICAgICBjb25zdCBjZWxscyA9IHRoaXMuZ2V0Q2VsbHMoKTtcbiAgICAgICAgaWYgKHRoaXMudmlzaXRlZENlbGxzQ291bnQgPT09IGNlbGxzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGNvbnN0IGNlbGwgPSBjZWxsc1t0aGlzLnZpc2l0ZWRDZWxsc0NvdW50XTtcbiAgICAgICAgY2VsbC52aXNpdCgpO1xuICAgICAgICB0aGlzLnZpc2l0ZWRDZWxsc0NvdW50Kys7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJpYyBpbXBsZW1lbnRhdGlvbiBvZiBicmVhZHRoLWZpcnN0IHNlYXJjaC4gUmV0dXJucyBub3RoaW5nLCBidXQgZXhwb3Nlc1xuICAgICAqIGN1c3RvbWl6YWJsZSBmdW5jdGlvbmFsaXR5IHZpYSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2VsbH0gc3RhcnRDZWxsIC0gQ2VsbCB0byBiZWdpbiBzZWFyY2hpbmcgb3V0d2FyZHMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRha2VzIHBhcmVudCBDZWxsLCBmb2xsb3dlZCBieSBpdHMgY2hpbGQgQ2VsbC5cbiAgICAgKi9cbiAgICBicmVhZHRoRmlyc3RTZWFyY2goc3RhcnRDZWxsLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBkaXN0YW5jZURpY3QgPSB7fTtcbiAgICAgICAgY29uc3QgdmlzaXRlZENlbGxzID0gbmV3IFNldChbc3RhcnRDZWxsXSk7XG5cbiAgICAgICAgbGV0IGZyb250aWVyQ2VsbHMgPSBbc3RhcnRDZWxsXTtcblxuICAgICAgICB3aGlsZSAoZnJvbnRpZXJDZWxscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0Zyb250aWVyID0gW107XG4gICAgICAgICAgICBmcm9udGllckNlbGxzLmZvckVhY2goKGNlbGwpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhY2Nlc3NpYmxlTmVpZ2hib3JzID0gY2VsbC5nZXRBY2Nlc3NpYmxlTmVpZ2hib3JzKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdW52aXNpdGVkQWNjZXNzaWJsZSA9IGFjY2Vzc2libGVOZWlnaGJvcnMuZmlsdGVyKChuZWlnaGJvcikgPT4gIXZpc2l0ZWRDZWxscy5oYXMobmVpZ2hib3IpKTtcblxuICAgICAgICAgICAgICAgIHVudmlzaXRlZEFjY2Vzc2libGUuZm9yRWFjaCgodW52aXNpdGVkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGNlbGwsIHVudmlzaXRlZClcbiAgICAgICAgICAgICAgICAgICAgbmV3RnJvbnRpZXIucHVzaCh1bnZpc2l0ZWQpO1xuICAgICAgICAgICAgICAgICAgICB2aXNpdGVkQ2VsbHMuYWRkKHVudmlzaXRlZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZyb250aWVyQ2VsbHMgPSBuZXdGcm9udGllcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBkaXN0YW5jZSBvZiBhbGwgbWF6ZSBjZWxscyBmcm9tIGNlbGwgYXQgZ2l2ZW4gaW5kZXgsXG4gICAgICogdGhlbiB1c2UgY29sb3IgdG8gdmlzdWFsaXplIGRpc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SWR4IC0gSW5kZXggb2Ygc2VsZWN0ZWQgc3RhcnQgY2VsbC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxDZWxsLCBudW1iZXI+fSBEaWN0aW9uYXJ5IG9mIGRpc3RhbmNlcyBmcm9tIHN0YXJ0IGNlbGwuXG4gICAgICovXG4gICAgZ2V0RGlzdGFuY2VEaWN0KHN0YXJ0SWR4KXtcbiAgICAgICAgY29uc3Qgc3RhcnRDZWxsID0gdGhpcy5nZXRDZWxscygpW3N0YXJ0SWR4XTtcbiAgICAgICAgY29uc3QgZGlzdGFuY2VEaWN0ID0ge31cbiAgICAgICAgZGlzdGFuY2VEaWN0W3N0YXJ0Q2VsbF0gPSAwO1xuXG4gICAgICAgIHRoaXMuYnJlYWR0aEZpcnN0U2VhcmNoKHN0YXJ0Q2VsbCwgKHBhcmVudCwgY2hpbGQpPT57XG4gICAgICAgICAgICBkaXN0YW5jZURpY3RbY2hpbGRdID0gZGlzdGFuY2VEaWN0W3BhcmVudF0gKyAxO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZGlzdGFuY2VEaWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZXMgYnJlYWR0aC1maXJzdCBzZWFyY2ggdG8gZmluZCB0aGUgc2hvcnRlc3QgcGF0aCBiZXR3ZWVuIHR3byBjZWxscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydElkeCAtIEluZGV4IG9mIHN0YXJ0IGNlbGwuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZElkeCAtIEluZGV4IG9mIGVuZCBjZWxsLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gTGlzdCBvZiBjZWxscyBpbiBzaG9ydGVzdCBwYXRoIChpbmNsdWRpbmcgc3RhcnQgYW5kIGVuZCBjZWxsKS5cbiAgICAgKi9cbiAgICBnZXRTaG9ydGVzdFBhdGhEYXRhKHN0YXJ0SWR4LCBlbmRJZHgpe1xuICAgICAgICBjb25zdCBjZWxscyA9IHRoaXMuZ2V0Q2VsbHMoKTtcbiAgICAgICAgY29uc3Qgc3RhcnRDZWxsID0gY2VsbHNbc3RhcnRJZHhdO1xuICAgICAgICBjb25zdCBlbmRDZWxsID0gY2VsbHNbZW5kSWR4XTtcblxuICAgICAgICBjb25zdCBwcmV2aW91c0RpY3QgPSB7fVxuICAgICAgICBwcmV2aW91c0RpY3Rbc3RhcnRDZWxsXSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5icmVhZHRoRmlyc3RTZWFyY2goc3RhcnRDZWxsLCAocGFyZW50LCBjaGlsZCkgPT4ge1xuICAgICAgICAgICAgcHJldmlvdXNEaWN0W2NoaWxkXSA9IHBhcmVudDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcGF0aCA9IFtdO1xuXG4gICAgICAgIGxldCBwcmV2Q2VsbCA9IGVuZENlbGw7XG4gICAgICAgIHdoaWxlIChwcmV2Q2VsbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcGF0aC51bnNoaWZ0KHByZXZDZWxsKVxuICAgICAgICAgICAgcHJldkNlbGwgPSBwcmV2aW91c0RpY3RbcHJldkNlbGxdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNYXplO1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function($) {/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n/* harmony import */ var _static_images_GitHub_Mark_Light_64px_png__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);\n/* harmony import */ var _static_images_GitHub_Mark_Light_64px_png__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_static_images_GitHub_Mark_Light_64px_png__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _Maze_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);\n/* harmony import */ var _Wall_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);\n\n\n\n\n\n\nconst DISTANCE_MAP_ANIMATION_SPEED = 40; // Delay (in milliseconds) between distance steps.\nconst ANIMATION_SPEED = 40; // Delay (in milliseconds) between cell visits.\n\n// Min & max values for random mazes in animation mode.\nconst MIN_RANDOM = 6;\nconst MAX_RANDOM = 30;\n\n// Min & max for minor (i.e. short or narrow) axis of random mazes on mobile.\nconst MIN_MOBILE_MINOR = 5;\nconst MAX_MOBILE_MINOR = 10;\n\n// Min & max for major (i.e. long or wide) axis of random mazes on mobile.\nconst MIN_MOBILE_MAJOR = 10;\nconst MAX_MOBILE_MAJOR = 20;\n\n// Min & max values for user input dimensions.\nconst MIN_CUSTOM = 3;\nconst MAX_CUSTOM = 40;\n\nconst InteractionMode = {\n    SHORTEST_PATH: 'SHORTEST_PATH',\n    DISTANCE_MAP: 'DISTANCE_MAP',\n};\n\n// Helper methods\n\nfunction getColorForNormalizedDistance(distance) {\n   return `hsl(${300 * distance}, 100%, 40%)`;\n}\n\nclass MazeDemoPage {\n    constructor() {\n        this.updateRanges();\n        this.randomizeDimensions();\n\n        this.maze = null;\n\n        this.isMobile = null;\n        this.isLandscape =  null;\n\n        this.currentMode = InteractionMode.DISTANCE_MAP;\n        this.isAnimating = false;\n        this.screenSaverInterval = null;\n\n        this.pathStart = null;\n        this.pathEnd = null;\n        this.pathLength = 0;\n        this.maxLength = 0;\n\n        this.pathLength$ = $('#path-length');\n        this.maxLength$ = $('#max-length');\n\n        this.maze$ = $('#maze');\n        this.mazeBg$ = $('#maze-background');\n\n        const templates$ = $('#templates');\n        this.cellTpl$ = templates$.find('.cell');\n        this.cells$ = {};\n\n        this.tooltip$ = $('#tooltip');\n        this.toolbar$ = $('#toolbar');\n\n        $('#github-link').css('background-image', `url(${_static_images_GitHub_Mark_Light_64px_png__WEBPACK_IMPORTED_MODULE_1___default.a})`);\n\n        this.hookEvents();\n    }\n\n    hookEvents() {\n        window.onresize = () => {\n            this.updateView();\n            this.updateRanges();\n        };\n\n        this.maze$\n            .on('mouseover', '.cell', (e) => {\n                e.stopPropagation();\n\n                const cell$ = $(e.currentTarget);\n\n                if (this.isAnimating) return;\n                else if (this.currentMode === InteractionMode.SHORTEST_PATH) {\n                    if (!this.pathStart || this.pathEnd) return;\n                    this.updatePath(this.pathStart, cell$.attr('id'));\n                    this.tooltip$.show();\n                } else if (this.currentMode === InteractionMode.DISTANCE_MAP) {\n                    this.drawDistanceMap(cell$);\n                }\n            })\n            .on('click', '.cell', (e) => {\n                e.stopPropagation();\n                const cell$ = $(e.currentTarget);\n\n                if (this.isAnimating) return;\n                else if (this.currentMode === InteractionMode.SHORTEST_PATH) {\n                    const cellId = cell$.attr('id');\n\n                    if (this.pathStart && !this.pathEnd) {\n                        this.pathEnd = cellId;\n                        this.tooltip$.hide();\n                    } else {\n                        this.pathStart = cellId;\n                        this.pathEnd = null;\n\n                        this.pathLength = 0;\n                        this.maxLength = 0;\n                    }\n\n                    this.updatePath(this.pathStart, this.pathEnd);\n                } else if (this.currentMode === InteractionMode.DISTANCE_MAP) {\n                    this.animateDistanceMap(cell$);\n                }\n            });\n\n        this.toolbar$\n            .on('click', '#distance-map:not(.active)', () => {\n                this.currentMode = InteractionMode.DISTANCE_MAP;\n                this.clearPath();\n                $('#shortest-path').removeClass('active');\n                $('#distance-map').addClass('active');\n            })\n            .on('click', '#shortest-path:not(.active)', () => {\n                this.currentMode = InteractionMode.SHORTEST_PATH;\n                $('#distance-map').removeClass('active');\n                $('#shortest-path').addClass('active');\n            });\n\n        $('#new-maze').click(() => {\n            this.nRows = $('#rows').val();\n            this.nCols = $('#cols').val();\n            this.startMaze();\n        });\n\n        $('#new-maze input')\n            .click((e) => {\n                e.stopPropagation();\n            })\n            .focus((e) => {\n                const input$ = $(e.target);\n                input$.data('previous', parseInt(input$.val()));\n            })\n            .change((e) => {\n                const input$ = $(e.target);\n                const inputValue = parseInt(input$.val());\n                const prevValue = input$.data('previous');\n\n                const newValue = Math.max(Math.min(inputValue || prevValue, MAX_CUSTOM), MIN_CUSTOM);\n                input$.val(newValue);\n\n                if (newValue !== prevValue) {\n                    this.resizeInput(input$, newValue);\n                    $('#new-maze').click();\n                }\n            });\n\n        $('#start-animating').click(() => this.startAnimating());\n        $('#stop-animating').click(()=>this.stopAnimating());\n\n        $('body')\n            .on('mouseover', () => {\n                if (this.isAnimating) return;\n                else if (this.currentMode === InteractionMode.DISTANCE_MAP) {\n                    Object.values(this.cells$).forEach((cell$) => cell$.find('.walls').css('background-color', ''));\n                    this.mazeBg$.removeClass('highlight-foreground');\n                }\n                this.tooltip$.hide();\n            })\n            .on('click', () => {\n                if (this.isAnimating) return;\n                else if (this.currentMode === InteractionMode.SHORTEST_PATH) {\n                    this.clearPath();\n                }\n            });\n\n        $(document)\n            .on('mousemove', (e) => {\n                this.updateTooltip(e);\n            });\n    }\n\n    setupView() {\n        this.maze$.empty();\n        this.cells$ = {};\n\n        const cells = this.maze.getCells()\n        cells.forEach((cell, idx) => {\n            const newCell$ = this.cellTpl$.clone();\n            newCell$.attr('id', idx);\n\n            this.cells$[cell] = newCell$;\n            this.maze$.append(newCell$);\n        });\n\n        this.maze$.css({\n            'grid-template-rows': `repeat(${this.nRows}, 1fr)`,\n            'grid-template-columns': `repeat(${this.nCols}, 1fr)`\n        });\n\n        this.resizeInput($('#rows').val(this.nRows), this.nRows);\n        this.resizeInput($('#cols').val(this.nCols), this.nCols);\n\n        this.updateView();\n    }\n\n    updateRanges() {\n        const isMobile = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[/* getDeviceType */ \"a\"])()\n        const isLandscape = window.innerWidth > window.innerHeight;\n        const hasChanged = (isMobile !== this.isMobile || (isMobile && isLandscape !== this.isLandscape));\n\n        if (!hasChanged) return;\n\n        if (isMobile) {\n            if (isLandscape) {\n                this.minRandRows = MIN_MOBILE_MINOR;\n                this.maxRandRows = MAX_MOBILE_MINOR;\n                this.minRandCols = MIN_MOBILE_MAJOR;\n                this.maxRandCols = MAX_MOBILE_MAJOR;\n            } else {\n                this.minRandRows = MIN_MOBILE_MAJOR;\n                this.maxRandRows = MAX_MOBILE_MAJOR;\n                this.minRandCols = MIN_MOBILE_MINOR;\n                this.maxRandCols = MAX_MOBILE_MINOR;\n            }\n        } else {\n            this.minRandRows = MIN_RANDOM;\n            this.maxRandRows = MAX_RANDOM;\n            this.minRandCols = MIN_RANDOM;\n            this.maxRandCols = MAX_RANDOM;\n        }\n\n        // Restart animation if ranges change.\n        if (this.isMobile !== null && this.isLandscape !== null && this.screenSaverInterval) {\n            this.stopAnimating();\n            this.startAnimating();\n        }\n\n        this.isMobile = isMobile;\n        this.isLandscape = isLandscape;\n    }\n\n    randomizeDimensions() {\n        this.nRows = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[/* randInt */ \"c\"])(this.minRandRows, this.maxRandRows);\n        this.nCols = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[/* randInt */ \"c\"])(this.minRandCols, this.maxRandCols);\n    }\n\n    updateView() {\n        const mazeAspect = this.nRows / this.nCols;\n        const screenAspect = window.innerHeight / window.innerWidth;\n\n        $('body').toggleClass('mobile', Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[/* getDeviceType */ \"a\"])() && screenAspect > 1);\n\n        this.mazeBg$.css({\n            width: screenAspect > mazeAspect ? '80vw' : `${80/mazeAspect}vh` ,\n            height: mazeAspect >= screenAspect ? '80vh' : `${80*mazeAspect}vw`\n        });\n\n        const defaultCell$ = this.maze$.find('.cell').first();\n\n        // If cell has open any walls, remove classes before calculating padding.\n        const classes = defaultCell$.attr('class');\n        const removeClasses = classes.split(' ').length > 1;\n        if (removeClasses) {\n            defaultCell$.attr('class', 'cell');\n        }\n\n        const defaultWall$ = defaultCell$.find('.walls');\n        const mazePadding = (defaultCell$.width()-defaultWall$.width())/2;\n\n        if (removeClasses) {\n            defaultCell$.attr('class', classes);\n        }\n\n        this.mazeBg$.css({\n            padding: mazePadding,\n            'border-radius': mazePadding * 1.5\n        });\n\n        $('.vertex').css({\n            top: -mazePadding,\n            right: -mazePadding,\n            height: mazePadding*2,\n            width: mazePadding*2,\n            'border-radius': mazePadding\n        });\n    }\n\n    updatePath(start, end) {\n        Object.values(this.cells$).forEach(cell$ => cell$.removeClass('path-start path-end path-middle'));\n        if (!(start || end)) {\n            this.mazeBg$.removeClass('highlight-foreground');\n            return;\n        }\n\n        this.mazeBg$.addClass('highlight-foreground');\n\n        if (!end) {\n            const cells = this.maze.getCells();\n            this.cells$[cells[start]].addClass('path-start');\n            return;\n        }\n\n        const pathData = this.maze.getShortestPathData(start, end);\n        this.pathLength = pathData.length-1;\n        this.maxLength = Math.max(this.maxLength, this.pathLength);\n\n        pathData.forEach((cell, idx) => {\n            const cell$ = this.cells$[cell];\n            cell$.addClass(idx === 0 ? 'path-start' : idx === pathData.length - 1 ? 'path-end' : 'path-middle')\n        });\n\n        this.renderMaze(false);\n    }\n\n    clearPath() {\n        this.pathStart = null;\n        this.pathEnd = null;\n        this.updatePath(null, null);\n        this.tooltip$.hide();\n    }\n\n    updateTooltip(e) {\n        this.tooltip$.css({ top: e.clientY - this.tooltip$.innerHeight() - 20, left: e.clientX - this.tooltip$.innerWidth() / 2 });\n        this.pathLength$.html(this.pathLength);\n        this.maxLength$.html(this.maxLength);\n    }\n\n    resizeInput(input$, value) {\n        input$.css('margin', `0 -${6 * (value >= 10 ? 1 : 2)}px`);\n    }\n\n    renderMaze(withColor) {\n        const cells = this.maze.getCells();\n\n        cells.forEach((cell) => {\n            const cell$ = this.cells$[cell];\n            const wallDict = cell.getWalls();\n\n            Object.keys(wallDict).forEach((key) => {\n                if (wallDict[key].state === _Wall_js__WEBPACK_IMPORTED_MODULE_3__[/* WallState */ \"a\"].REMOVED){\n                    cell$.addClass(`open-${key}`);\n                }\n            });\n\n            const cellColor = withColor && cell.visited ? cell.group.color : '';\n            cell$.find('.walls').css('background-color', cellColor);\n\n            cell$.toggleClass('pending', !cell.visited);\n        });\n    }\n\n    startMaze() {\n        this.maze = new _Maze_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"](this.nRows, this.nCols);\n        this.setupView();\n\n        this.maze.generateMaze();\n        this.renderMaze(false);\n    }\n\n    startAnimating() {\n        this.isAnimating = true;\n\n        this.mazeBg$.addClass('highlight-foreground');\n\n        this.toolbar$.addClass('animating');\n        $('#new-maze, #interaction-mode .tool-option').disable();\n\n        let roundsToSkip = 1;\n        this.screenSaverInterval = setInterval(() => {\n            if (roundsToSkip > 0) {\n                roundsToSkip--;\n                if (!roundsToSkip) {\n                    this.randomizeDimensions();\n\n                    this.maze = new _Maze_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"](this.nRows, this.nCols);\n                    this.setupView();\n                }\n            } else {\n                const shouldRepeat = this.maze.generateNextCell();\n                this.renderMaze(true);\n\n                if (!shouldRepeat) {\n                    roundsToSkip = 30;\n                }\n            }\n        }, ANIMATION_SPEED);\n    }\n\n    stopAnimating() {\n        this.isAnimating = false;\n\n        this.mazeBg$.removeClass('highlight-foreground');\n\n        this.toolbar$.removeClass('animating');\n        $('#new-maze, #interaction-mode .tool-option').enable();\n\n        clearInterval(this.screenSaverInterval);\n        this.screenSaverInterval = null;\n\n        while (this.maze.generateNextCell()) {}\n\n        this.renderMaze();\n    }\n\n    drawDistanceMap(startCell$) {\n        const distanceDict = this.maze.getDistanceDict(startCell$.attr('id'));\n        const maxDist = Object.values(distanceDict).sort((a, b) => parseInt(a) > parseInt(b) ? -1 : 1)[0];\n\n        // Set hue by normalized distance (i.e. fraction of max dist).\n        this.maze.getCells().forEach((cell) => {\n            this.cells$[cell].find('.walls').css('background-color', getColorForNormalizedDistance(distanceDict[cell] / maxDist));\n        });\n\n        this.mazeBg$.addClass('highlight-foreground');\n    }\n\n    animateDistanceMap(startCell$) {\n        this.isAnimating = true;\n        this.renderMaze(false);\n\n        this.toolbar$.find('.tool-option').disable();\n\n        const distanceDict = this.maze.getDistanceDict(startCell$.attr('id'));\n        const reversedDict = {};\n        Object.keys(distanceDict).forEach((cell) => {\n            const distance = distanceDict[cell];\n            if (!(distance in reversedDict)) {\n                reversedDict[distance] = [];\n            }\n            reversedDict[distance].push(cell)\n        });\n        const maxDist = Object.keys(reversedDict).length;\n        let currentDist = 0;\n        const distanceInterval = setInterval(()=>{\n            if (currentDist < maxDist) {\n                const cells = reversedDict[currentDist];\n                cells.forEach((cell)=>{\n                    this.cells$[cell].find('.walls').css('background-color', getColorForNormalizedDistance(currentDist / maxDist));\n                });\n                currentDist++;\n            }\n            else {\n                clearInterval(distanceInterval);\n\n                this.isAnimating = false;\n                this.toolbar$.find('.tool-option').enable();\n            }\n        }, DISTANCE_MAP_ANIMATION_SPEED);\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (MazeDemoPage);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(4)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy9NYXplRGVtb1BhZ2UuanM/YjUxMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3JhbmRJbnQsIGdldERldmljZVR5cGV9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IEdpdEh1YkxvZ28gZnJvbSAnLi4vLi4vc3RhdGljL2ltYWdlcy9HaXRIdWItTWFyay1MaWdodC02NHB4LnBuZyc7XG5pbXBvcnQgTWF6ZSBmcm9tICcuL01hemUuanMnO1xuaW1wb3J0IFdhbGwgZnJvbSAnLi9XYWxsLmpzJ1xuaW1wb3J0IHtXYWxsU3RhdGV9IGZyb20gJy4vV2FsbC5qcydcblxuY29uc3QgRElTVEFOQ0VfTUFQX0FOSU1BVElPTl9TUEVFRCA9IDQwOyAvLyBEZWxheSAoaW4gbWlsbGlzZWNvbmRzKSBiZXR3ZWVuIGRpc3RhbmNlIHN0ZXBzLlxuY29uc3QgQU5JTUFUSU9OX1NQRUVEID0gNDA7IC8vIERlbGF5IChpbiBtaWxsaXNlY29uZHMpIGJldHdlZW4gY2VsbCB2aXNpdHMuXG5cbi8vIE1pbiAmIG1heCB2YWx1ZXMgZm9yIHJhbmRvbSBtYXplcyBpbiBhbmltYXRpb24gbW9kZS5cbmNvbnN0IE1JTl9SQU5ET00gPSA2O1xuY29uc3QgTUFYX1JBTkRPTSA9IDMwO1xuXG4vLyBNaW4gJiBtYXggZm9yIG1pbm9yIChpLmUuIHNob3J0IG9yIG5hcnJvdykgYXhpcyBvZiByYW5kb20gbWF6ZXMgb24gbW9iaWxlLlxuY29uc3QgTUlOX01PQklMRV9NSU5PUiA9IDU7XG5jb25zdCBNQVhfTU9CSUxFX01JTk9SID0gMTA7XG5cbi8vIE1pbiAmIG1heCBmb3IgbWFqb3IgKGkuZS4gbG9uZyBvciB3aWRlKSBheGlzIG9mIHJhbmRvbSBtYXplcyBvbiBtb2JpbGUuXG5jb25zdCBNSU5fTU9CSUxFX01BSk9SID0gMTA7XG5jb25zdCBNQVhfTU9CSUxFX01BSk9SID0gMjA7XG5cbi8vIE1pbiAmIG1heCB2YWx1ZXMgZm9yIHVzZXIgaW5wdXQgZGltZW5zaW9ucy5cbmNvbnN0IE1JTl9DVVNUT00gPSAzO1xuY29uc3QgTUFYX0NVU1RPTSA9IDQwO1xuXG5jb25zdCBJbnRlcmFjdGlvbk1vZGUgPSB7XG4gICAgU0hPUlRFU1RfUEFUSDogJ1NIT1JURVNUX1BBVEgnLFxuICAgIERJU1RBTkNFX01BUDogJ0RJU1RBTkNFX01BUCcsXG59O1xuXG4vLyBIZWxwZXIgbWV0aG9kc1xuXG5mdW5jdGlvbiBnZXRDb2xvckZvck5vcm1hbGl6ZWREaXN0YW5jZShkaXN0YW5jZSkge1xuICAgcmV0dXJuIGBoc2woJHszMDAgKiBkaXN0YW5jZX0sIDEwMCUsIDQwJSlgO1xufVxuXG5jbGFzcyBNYXplRGVtb1BhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVJhbmdlcygpO1xuICAgICAgICB0aGlzLnJhbmRvbWl6ZURpbWVuc2lvbnMoKTtcblxuICAgICAgICB0aGlzLm1hemUgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuaXNNb2JpbGUgPSBudWxsO1xuICAgICAgICB0aGlzLmlzTGFuZHNjYXBlID0gIG51bGw7XG5cbiAgICAgICAgdGhpcy5jdXJyZW50TW9kZSA9IEludGVyYWN0aW9uTW9kZS5ESVNUQU5DRV9NQVA7XG4gICAgICAgIHRoaXMuaXNBbmltYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zY3JlZW5TYXZlckludGVydmFsID0gbnVsbDtcblxuICAgICAgICB0aGlzLnBhdGhTdGFydCA9IG51bGw7XG4gICAgICAgIHRoaXMucGF0aEVuZCA9IG51bGw7XG4gICAgICAgIHRoaXMucGF0aExlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMubWF4TGVuZ3RoID0gMDtcblxuICAgICAgICB0aGlzLnBhdGhMZW5ndGgkID0gJCgnI3BhdGgtbGVuZ3RoJyk7XG4gICAgICAgIHRoaXMubWF4TGVuZ3RoJCA9ICQoJyNtYXgtbGVuZ3RoJyk7XG5cbiAgICAgICAgdGhpcy5tYXplJCA9ICQoJyNtYXplJyk7XG4gICAgICAgIHRoaXMubWF6ZUJnJCA9ICQoJyNtYXplLWJhY2tncm91bmQnKTtcblxuICAgICAgICBjb25zdCB0ZW1wbGF0ZXMkID0gJCgnI3RlbXBsYXRlcycpO1xuICAgICAgICB0aGlzLmNlbGxUcGwkID0gdGVtcGxhdGVzJC5maW5kKCcuY2VsbCcpO1xuICAgICAgICB0aGlzLmNlbGxzJCA9IHt9O1xuXG4gICAgICAgIHRoaXMudG9vbHRpcCQgPSAkKCcjdG9vbHRpcCcpO1xuICAgICAgICB0aGlzLnRvb2xiYXIkID0gJCgnI3Rvb2xiYXInKTtcblxuICAgICAgICAkKCcjZ2l0aHViLWxpbmsnKS5jc3MoJ2JhY2tncm91bmQtaW1hZ2UnLCBgdXJsKCR7R2l0SHViTG9nb30pYCk7XG5cbiAgICAgICAgdGhpcy5ob29rRXZlbnRzKCk7XG4gICAgfVxuXG4gICAgaG9va0V2ZW50cygpIHtcbiAgICAgICAgd2luZG93Lm9ucmVzaXplID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3KCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVJhbmdlcygpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMubWF6ZSRcbiAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgJy5jZWxsJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbCQgPSAkKGUuY3VycmVudFRhcmdldCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0FuaW1hdGluZykgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY3VycmVudE1vZGUgPT09IEludGVyYWN0aW9uTW9kZS5TSE9SVEVTVF9QQVRIKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5wYXRoU3RhcnQgfHwgdGhpcy5wYXRoRW5kKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUGF0aCh0aGlzLnBhdGhTdGFydCwgY2VsbCQuYXR0cignaWQnKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9vbHRpcCQuc2hvdygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5jdXJyZW50TW9kZSA9PT0gSW50ZXJhY3Rpb25Nb2RlLkRJU1RBTkNFX01BUCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdEaXN0YW5jZU1hcChjZWxsJCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignY2xpY2snLCAnLmNlbGwnLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbCQgPSAkKGUuY3VycmVudFRhcmdldCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0FuaW1hdGluZykgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY3VycmVudE1vZGUgPT09IEludGVyYWN0aW9uTW9kZS5TSE9SVEVTVF9QQVRIKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxJZCA9IGNlbGwkLmF0dHIoJ2lkJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGF0aFN0YXJ0ICYmICF0aGlzLnBhdGhFbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGF0aEVuZCA9IGNlbGxJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9vbHRpcCQuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoU3RhcnQgPSBjZWxsSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdGhFbmQgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdGhMZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXhMZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQYXRoKHRoaXMucGF0aFN0YXJ0LCB0aGlzLnBhdGhFbmQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5jdXJyZW50TW9kZSA9PT0gSW50ZXJhY3Rpb25Nb2RlLkRJU1RBTkNFX01BUCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGVEaXN0YW5jZU1hcChjZWxsJCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy50b29sYmFyJFxuICAgICAgICAgICAgLm9uKCdjbGljaycsICcjZGlzdGFuY2UtbWFwOm5vdCguYWN0aXZlKScsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRNb2RlID0gSW50ZXJhY3Rpb25Nb2RlLkRJU1RBTkNFX01BUDtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyUGF0aCgpO1xuICAgICAgICAgICAgICAgICQoJyNzaG9ydGVzdC1wYXRoJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICAgICQoJyNkaXN0YW5jZS1tYXAnKS5hZGRDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdjbGljaycsICcjc2hvcnRlc3QtcGF0aDpub3QoLmFjdGl2ZSknLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50TW9kZSA9IEludGVyYWN0aW9uTW9kZS5TSE9SVEVTVF9QQVRIO1xuICAgICAgICAgICAgICAgICQoJyNkaXN0YW5jZS1tYXAnKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgJCgnI3Nob3J0ZXN0LXBhdGgnKS5hZGRDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAkKCcjbmV3LW1hemUnKS5jbGljaygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm5Sb3dzID0gJCgnI3Jvd3MnKS52YWwoKTtcbiAgICAgICAgICAgIHRoaXMubkNvbHMgPSAkKCcjY29scycpLnZhbCgpO1xuICAgICAgICAgICAgdGhpcy5zdGFydE1hemUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJCgnI25ldy1tYXplIGlucHV0JylcbiAgICAgICAgICAgIC5jbGljaygoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZvY3VzKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5wdXQkID0gJChlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgaW5wdXQkLmRhdGEoJ3ByZXZpb3VzJywgcGFyc2VJbnQoaW5wdXQkLnZhbCgpKSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNoYW5nZSgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0JCA9ICQoZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0VmFsdWUgPSBwYXJzZUludChpbnB1dCQudmFsKCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZWYWx1ZSA9IGlucHV0JC5kYXRhKCdwcmV2aW91cycpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBNYXRoLm1heChNYXRoLm1pbihpbnB1dFZhbHVlIHx8IHByZXZWYWx1ZSwgTUFYX0NVU1RPTSksIE1JTl9DVVNUT00pO1xuICAgICAgICAgICAgICAgIGlucHV0JC52YWwobmV3VmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSBwcmV2VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNpemVJbnB1dChpbnB1dCQsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgJCgnI25ldy1tYXplJykuY2xpY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAkKCcjc3RhcnQtYW5pbWF0aW5nJykuY2xpY2soKCkgPT4gdGhpcy5zdGFydEFuaW1hdGluZygpKTtcbiAgICAgICAgJCgnI3N0b3AtYW5pbWF0aW5nJykuY2xpY2soKCk9PnRoaXMuc3RvcEFuaW1hdGluZygpKTtcblxuICAgICAgICAkKCdib2R5JylcbiAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQW5pbWF0aW5nKSByZXR1cm47XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jdXJyZW50TW9kZSA9PT0gSW50ZXJhY3Rpb25Nb2RlLkRJU1RBTkNFX01BUCkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QudmFsdWVzKHRoaXMuY2VsbHMkKS5mb3JFYWNoKChjZWxsJCkgPT4gY2VsbCQuZmluZCgnLndhbGxzJykuY3NzKCdiYWNrZ3JvdW5kLWNvbG9yJywgJycpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXplQmckLnJlbW92ZUNsYXNzKCdoaWdobGlnaHQtZm9yZWdyb3VuZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnRvb2x0aXAkLmhpZGUoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQW5pbWF0aW5nKSByZXR1cm47XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jdXJyZW50TW9kZSA9PT0gSW50ZXJhY3Rpb25Nb2RlLlNIT1JURVNUX1BBVEgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhclBhdGgoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAkKGRvY3VtZW50KVxuICAgICAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVG9vbHRpcChlKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIHNldHVwVmlldygpIHtcbiAgICAgICAgdGhpcy5tYXplJC5lbXB0eSgpO1xuICAgICAgICB0aGlzLmNlbGxzJCA9IHt9O1xuXG4gICAgICAgIGNvbnN0IGNlbGxzID0gdGhpcy5tYXplLmdldENlbGxzKClcbiAgICAgICAgY2VsbHMuZm9yRWFjaCgoY2VsbCwgaWR4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdDZWxsJCA9IHRoaXMuY2VsbFRwbCQuY2xvbmUoKTtcbiAgICAgICAgICAgIG5ld0NlbGwkLmF0dHIoJ2lkJywgaWR4KTtcblxuICAgICAgICAgICAgdGhpcy5jZWxscyRbY2VsbF0gPSBuZXdDZWxsJDtcbiAgICAgICAgICAgIHRoaXMubWF6ZSQuYXBwZW5kKG5ld0NlbGwkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5tYXplJC5jc3Moe1xuICAgICAgICAgICAgJ2dyaWQtdGVtcGxhdGUtcm93cyc6IGByZXBlYXQoJHt0aGlzLm5Sb3dzfSwgMWZyKWAsXG4gICAgICAgICAgICAnZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zJzogYHJlcGVhdCgke3RoaXMubkNvbHN9LCAxZnIpYFxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnJlc2l6ZUlucHV0KCQoJyNyb3dzJykudmFsKHRoaXMublJvd3MpLCB0aGlzLm5Sb3dzKTtcbiAgICAgICAgdGhpcy5yZXNpemVJbnB1dCgkKCcjY29scycpLnZhbCh0aGlzLm5Db2xzKSwgdGhpcy5uQ29scyk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVWaWV3KCk7XG4gICAgfVxuXG4gICAgdXBkYXRlUmFuZ2VzKCkge1xuICAgICAgICBjb25zdCBpc01vYmlsZSA9IGdldERldmljZVR5cGUoKVxuICAgICAgICBjb25zdCBpc0xhbmRzY2FwZSA9IHdpbmRvdy5pbm5lcldpZHRoID4gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgICBjb25zdCBoYXNDaGFuZ2VkID0gKGlzTW9iaWxlICE9PSB0aGlzLmlzTW9iaWxlIHx8IChpc01vYmlsZSAmJiBpc0xhbmRzY2FwZSAhPT0gdGhpcy5pc0xhbmRzY2FwZSkpO1xuXG4gICAgICAgIGlmICghaGFzQ2hhbmdlZCkgcmV0dXJuO1xuXG4gICAgICAgIGlmIChpc01vYmlsZSkge1xuICAgICAgICAgICAgaWYgKGlzTGFuZHNjYXBlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5taW5SYW5kUm93cyA9IE1JTl9NT0JJTEVfTUlOT1I7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXhSYW5kUm93cyA9IE1BWF9NT0JJTEVfTUlOT1I7XG4gICAgICAgICAgICAgICAgdGhpcy5taW5SYW5kQ29scyA9IE1JTl9NT0JJTEVfTUFKT1I7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXhSYW5kQ29scyA9IE1BWF9NT0JJTEVfTUFKT1I7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubWluUmFuZFJvd3MgPSBNSU5fTU9CSUxFX01BSk9SO1xuICAgICAgICAgICAgICAgIHRoaXMubWF4UmFuZFJvd3MgPSBNQVhfTU9CSUxFX01BSk9SO1xuICAgICAgICAgICAgICAgIHRoaXMubWluUmFuZENvbHMgPSBNSU5fTU9CSUxFX01JTk9SO1xuICAgICAgICAgICAgICAgIHRoaXMubWF4UmFuZENvbHMgPSBNQVhfTU9CSUxFX01JTk9SO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5taW5SYW5kUm93cyA9IE1JTl9SQU5ET007XG4gICAgICAgICAgICB0aGlzLm1heFJhbmRSb3dzID0gTUFYX1JBTkRPTTtcbiAgICAgICAgICAgIHRoaXMubWluUmFuZENvbHMgPSBNSU5fUkFORE9NO1xuICAgICAgICAgICAgdGhpcy5tYXhSYW5kQ29scyA9IE1BWF9SQU5ET007XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXN0YXJ0IGFuaW1hdGlvbiBpZiByYW5nZXMgY2hhbmdlLlxuICAgICAgICBpZiAodGhpcy5pc01vYmlsZSAhPT0gbnVsbCAmJiB0aGlzLmlzTGFuZHNjYXBlICE9PSBudWxsICYmIHRoaXMuc2NyZWVuU2F2ZXJJbnRlcnZhbCkge1xuICAgICAgICAgICAgdGhpcy5zdG9wQW5pbWF0aW5nKCk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0QW5pbWF0aW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlzTW9iaWxlID0gaXNNb2JpbGU7XG4gICAgICAgIHRoaXMuaXNMYW5kc2NhcGUgPSBpc0xhbmRzY2FwZTtcbiAgICB9XG5cbiAgICByYW5kb21pemVEaW1lbnNpb25zKCkge1xuICAgICAgICB0aGlzLm5Sb3dzID0gcmFuZEludCh0aGlzLm1pblJhbmRSb3dzLCB0aGlzLm1heFJhbmRSb3dzKTtcbiAgICAgICAgdGhpcy5uQ29scyA9IHJhbmRJbnQodGhpcy5taW5SYW5kQ29scywgdGhpcy5tYXhSYW5kQ29scyk7XG4gICAgfVxuXG4gICAgdXBkYXRlVmlldygpIHtcbiAgICAgICAgY29uc3QgbWF6ZUFzcGVjdCA9IHRoaXMublJvd3MgLyB0aGlzLm5Db2xzO1xuICAgICAgICBjb25zdCBzY3JlZW5Bc3BlY3QgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLyB3aW5kb3cuaW5uZXJXaWR0aDtcblxuICAgICAgICAkKCdib2R5JykudG9nZ2xlQ2xhc3MoJ21vYmlsZScsIGdldERldmljZVR5cGUoKSAmJiBzY3JlZW5Bc3BlY3QgPiAxKTtcblxuICAgICAgICB0aGlzLm1hemVCZyQuY3NzKHtcbiAgICAgICAgICAgIHdpZHRoOiBzY3JlZW5Bc3BlY3QgPiBtYXplQXNwZWN0ID8gJzgwdncnIDogYCR7ODAvbWF6ZUFzcGVjdH12aGAgLFxuICAgICAgICAgICAgaGVpZ2h0OiBtYXplQXNwZWN0ID49IHNjcmVlbkFzcGVjdCA/ICc4MHZoJyA6IGAkezgwKm1hemVBc3BlY3R9dndgXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGRlZmF1bHRDZWxsJCA9IHRoaXMubWF6ZSQuZmluZCgnLmNlbGwnKS5maXJzdCgpO1xuXG4gICAgICAgIC8vIElmIGNlbGwgaGFzIG9wZW4gYW55IHdhbGxzLCByZW1vdmUgY2xhc3NlcyBiZWZvcmUgY2FsY3VsYXRpbmcgcGFkZGluZy5cbiAgICAgICAgY29uc3QgY2xhc3NlcyA9IGRlZmF1bHRDZWxsJC5hdHRyKCdjbGFzcycpO1xuICAgICAgICBjb25zdCByZW1vdmVDbGFzc2VzID0gY2xhc3Nlcy5zcGxpdCgnICcpLmxlbmd0aCA+IDE7XG4gICAgICAgIGlmIChyZW1vdmVDbGFzc2VzKSB7XG4gICAgICAgICAgICBkZWZhdWx0Q2VsbCQuYXR0cignY2xhc3MnLCAnY2VsbCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGVmYXVsdFdhbGwkID0gZGVmYXVsdENlbGwkLmZpbmQoJy53YWxscycpO1xuICAgICAgICBjb25zdCBtYXplUGFkZGluZyA9IChkZWZhdWx0Q2VsbCQud2lkdGgoKS1kZWZhdWx0V2FsbCQud2lkdGgoKSkvMjtcblxuICAgICAgICBpZiAocmVtb3ZlQ2xhc3Nlcykge1xuICAgICAgICAgICAgZGVmYXVsdENlbGwkLmF0dHIoJ2NsYXNzJywgY2xhc3Nlcyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1hemVCZyQuY3NzKHtcbiAgICAgICAgICAgIHBhZGRpbmc6IG1hemVQYWRkaW5nLFxuICAgICAgICAgICAgJ2JvcmRlci1yYWRpdXMnOiBtYXplUGFkZGluZyAqIDEuNVxuICAgICAgICB9KTtcblxuICAgICAgICAkKCcudmVydGV4JykuY3NzKHtcbiAgICAgICAgICAgIHRvcDogLW1hemVQYWRkaW5nLFxuICAgICAgICAgICAgcmlnaHQ6IC1tYXplUGFkZGluZyxcbiAgICAgICAgICAgIGhlaWdodDogbWF6ZVBhZGRpbmcqMixcbiAgICAgICAgICAgIHdpZHRoOiBtYXplUGFkZGluZyoyLFxuICAgICAgICAgICAgJ2JvcmRlci1yYWRpdXMnOiBtYXplUGFkZGluZ1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB1cGRhdGVQYXRoKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgT2JqZWN0LnZhbHVlcyh0aGlzLmNlbGxzJCkuZm9yRWFjaChjZWxsJCA9PiBjZWxsJC5yZW1vdmVDbGFzcygncGF0aC1zdGFydCBwYXRoLWVuZCBwYXRoLW1pZGRsZScpKTtcbiAgICAgICAgaWYgKCEoc3RhcnQgfHwgZW5kKSkge1xuICAgICAgICAgICAgdGhpcy5tYXplQmckLnJlbW92ZUNsYXNzKCdoaWdobGlnaHQtZm9yZWdyb3VuZCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYXplQmckLmFkZENsYXNzKCdoaWdobGlnaHQtZm9yZWdyb3VuZCcpO1xuXG4gICAgICAgIGlmICghZW5kKSB7XG4gICAgICAgICAgICBjb25zdCBjZWxscyA9IHRoaXMubWF6ZS5nZXRDZWxscygpO1xuICAgICAgICAgICAgdGhpcy5jZWxscyRbY2VsbHNbc3RhcnRdXS5hZGRDbGFzcygncGF0aC1zdGFydCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGF0aERhdGEgPSB0aGlzLm1hemUuZ2V0U2hvcnRlc3RQYXRoRGF0YShzdGFydCwgZW5kKTtcbiAgICAgICAgdGhpcy5wYXRoTGVuZ3RoID0gcGF0aERhdGEubGVuZ3RoLTE7XG4gICAgICAgIHRoaXMubWF4TGVuZ3RoID0gTWF0aC5tYXgodGhpcy5tYXhMZW5ndGgsIHRoaXMucGF0aExlbmd0aCk7XG5cbiAgICAgICAgcGF0aERhdGEuZm9yRWFjaCgoY2VsbCwgaWR4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjZWxsJCA9IHRoaXMuY2VsbHMkW2NlbGxdO1xuICAgICAgICAgICAgY2VsbCQuYWRkQ2xhc3MoaWR4ID09PSAwID8gJ3BhdGgtc3RhcnQnIDogaWR4ID09PSBwYXRoRGF0YS5sZW5ndGggLSAxID8gJ3BhdGgtZW5kJyA6ICdwYXRoLW1pZGRsZScpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMucmVuZGVyTWF6ZShmYWxzZSk7XG4gICAgfVxuXG4gICAgY2xlYXJQYXRoKCkge1xuICAgICAgICB0aGlzLnBhdGhTdGFydCA9IG51bGw7XG4gICAgICAgIHRoaXMucGF0aEVuZCA9IG51bGw7XG4gICAgICAgIHRoaXMudXBkYXRlUGF0aChudWxsLCBudWxsKTtcbiAgICAgICAgdGhpcy50b29sdGlwJC5oaWRlKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlVG9vbHRpcChlKSB7XG4gICAgICAgIHRoaXMudG9vbHRpcCQuY3NzKHsgdG9wOiBlLmNsaWVudFkgLSB0aGlzLnRvb2x0aXAkLmlubmVySGVpZ2h0KCkgLSAyMCwgbGVmdDogZS5jbGllbnRYIC0gdGhpcy50b29sdGlwJC5pbm5lcldpZHRoKCkgLyAyIH0pO1xuICAgICAgICB0aGlzLnBhdGhMZW5ndGgkLmh0bWwodGhpcy5wYXRoTGVuZ3RoKTtcbiAgICAgICAgdGhpcy5tYXhMZW5ndGgkLmh0bWwodGhpcy5tYXhMZW5ndGgpO1xuICAgIH1cblxuICAgIHJlc2l6ZUlucHV0KGlucHV0JCwgdmFsdWUpIHtcbiAgICAgICAgaW5wdXQkLmNzcygnbWFyZ2luJywgYDAgLSR7NiAqICh2YWx1ZSA+PSAxMCA/IDEgOiAyKX1weGApO1xuICAgIH1cblxuICAgIHJlbmRlck1hemUod2l0aENvbG9yKSB7XG4gICAgICAgIGNvbnN0IGNlbGxzID0gdGhpcy5tYXplLmdldENlbGxzKCk7XG5cbiAgICAgICAgY2VsbHMuZm9yRWFjaCgoY2VsbCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2VsbCQgPSB0aGlzLmNlbGxzJFtjZWxsXTtcbiAgICAgICAgICAgIGNvbnN0IHdhbGxEaWN0ID0gY2VsbC5nZXRXYWxscygpO1xuXG4gICAgICAgICAgICBPYmplY3Qua2V5cyh3YWxsRGljdCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHdhbGxEaWN0W2tleV0uc3RhdGUgPT09IFdhbGxTdGF0ZS5SRU1PVkVEKXtcbiAgICAgICAgICAgICAgICAgICAgY2VsbCQuYWRkQ2xhc3MoYG9wZW4tJHtrZXl9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGNlbGxDb2xvciA9IHdpdGhDb2xvciAmJiBjZWxsLnZpc2l0ZWQgPyBjZWxsLmdyb3VwLmNvbG9yIDogJyc7XG4gICAgICAgICAgICBjZWxsJC5maW5kKCcud2FsbHMnKS5jc3MoJ2JhY2tncm91bmQtY29sb3InLCBjZWxsQ29sb3IpO1xuXG4gICAgICAgICAgICBjZWxsJC50b2dnbGVDbGFzcygncGVuZGluZycsICFjZWxsLnZpc2l0ZWQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGFydE1hemUoKSB7XG4gICAgICAgIHRoaXMubWF6ZSA9IG5ldyBNYXplKHRoaXMublJvd3MsIHRoaXMubkNvbHMpO1xuICAgICAgICB0aGlzLnNldHVwVmlldygpO1xuXG4gICAgICAgIHRoaXMubWF6ZS5nZW5lcmF0ZU1hemUoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJNYXplKGZhbHNlKTtcbiAgICB9XG5cbiAgICBzdGFydEFuaW1hdGluZygpIHtcbiAgICAgICAgdGhpcy5pc0FuaW1hdGluZyA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5tYXplQmckLmFkZENsYXNzKCdoaWdobGlnaHQtZm9yZWdyb3VuZCcpO1xuXG4gICAgICAgIHRoaXMudG9vbGJhciQuYWRkQ2xhc3MoJ2FuaW1hdGluZycpO1xuICAgICAgICAkKCcjbmV3LW1hemUsICNpbnRlcmFjdGlvbi1tb2RlIC50b29sLW9wdGlvbicpLmRpc2FibGUoKTtcblxuICAgICAgICBsZXQgcm91bmRzVG9Ta2lwID0gMTtcbiAgICAgICAgdGhpcy5zY3JlZW5TYXZlckludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJvdW5kc1RvU2tpcCA+IDApIHtcbiAgICAgICAgICAgICAgICByb3VuZHNUb1NraXAtLTtcbiAgICAgICAgICAgICAgICBpZiAoIXJvdW5kc1RvU2tpcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJhbmRvbWl6ZURpbWVuc2lvbnMoKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hemUgPSBuZXcgTWF6ZSh0aGlzLm5Sb3dzLCB0aGlzLm5Db2xzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR1cFZpZXcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNob3VsZFJlcGVhdCA9IHRoaXMubWF6ZS5nZW5lcmF0ZU5leHRDZWxsKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJNYXplKHRydWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFzaG91bGRSZXBlYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcm91bmRzVG9Ta2lwID0gMzA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBBTklNQVRJT05fU1BFRUQpO1xuICAgIH1cblxuICAgIHN0b3BBbmltYXRpbmcoKSB7XG4gICAgICAgIHRoaXMuaXNBbmltYXRpbmcgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLm1hemVCZyQucmVtb3ZlQ2xhc3MoJ2hpZ2hsaWdodC1mb3JlZ3JvdW5kJyk7XG5cbiAgICAgICAgdGhpcy50b29sYmFyJC5yZW1vdmVDbGFzcygnYW5pbWF0aW5nJyk7XG4gICAgICAgICQoJyNuZXctbWF6ZSwgI2ludGVyYWN0aW9uLW1vZGUgLnRvb2wtb3B0aW9uJykuZW5hYmxlKCk7XG5cbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnNjcmVlblNhdmVySW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLnNjcmVlblNhdmVySW50ZXJ2YWwgPSBudWxsO1xuXG4gICAgICAgIHdoaWxlICh0aGlzLm1hemUuZ2VuZXJhdGVOZXh0Q2VsbCgpKSB7fVxuXG4gICAgICAgIHRoaXMucmVuZGVyTWF6ZSgpO1xuICAgIH1cblxuICAgIGRyYXdEaXN0YW5jZU1hcChzdGFydENlbGwkKSB7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlRGljdCA9IHRoaXMubWF6ZS5nZXREaXN0YW5jZURpY3Qoc3RhcnRDZWxsJC5hdHRyKCdpZCcpKTtcbiAgICAgICAgY29uc3QgbWF4RGlzdCA9IE9iamVjdC52YWx1ZXMoZGlzdGFuY2VEaWN0KS5zb3J0KChhLCBiKSA9PiBwYXJzZUludChhKSA+IHBhcnNlSW50KGIpID8gLTEgOiAxKVswXTtcblxuICAgICAgICAvLyBTZXQgaHVlIGJ5IG5vcm1hbGl6ZWQgZGlzdGFuY2UgKGkuZS4gZnJhY3Rpb24gb2YgbWF4IGRpc3QpLlxuICAgICAgICB0aGlzLm1hemUuZ2V0Q2VsbHMoKS5mb3JFYWNoKChjZWxsKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNlbGxzJFtjZWxsXS5maW5kKCcud2FsbHMnKS5jc3MoJ2JhY2tncm91bmQtY29sb3InLCBnZXRDb2xvckZvck5vcm1hbGl6ZWREaXN0YW5jZShkaXN0YW5jZURpY3RbY2VsbF0gLyBtYXhEaXN0KSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMubWF6ZUJnJC5hZGRDbGFzcygnaGlnaGxpZ2h0LWZvcmVncm91bmQnKTtcbiAgICB9XG5cbiAgICBhbmltYXRlRGlzdGFuY2VNYXAoc3RhcnRDZWxsJCkge1xuICAgICAgICB0aGlzLmlzQW5pbWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZW5kZXJNYXplKGZhbHNlKTtcblxuICAgICAgICB0aGlzLnRvb2xiYXIkLmZpbmQoJy50b29sLW9wdGlvbicpLmRpc2FibGUoKTtcblxuICAgICAgICBjb25zdCBkaXN0YW5jZURpY3QgPSB0aGlzLm1hemUuZ2V0RGlzdGFuY2VEaWN0KHN0YXJ0Q2VsbCQuYXR0cignaWQnKSk7XG4gICAgICAgIGNvbnN0IHJldmVyc2VkRGljdCA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhkaXN0YW5jZURpY3QpLmZvckVhY2goKGNlbGwpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gZGlzdGFuY2VEaWN0W2NlbGxdO1xuICAgICAgICAgICAgaWYgKCEoZGlzdGFuY2UgaW4gcmV2ZXJzZWREaWN0KSkge1xuICAgICAgICAgICAgICAgIHJldmVyc2VkRGljdFtkaXN0YW5jZV0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldmVyc2VkRGljdFtkaXN0YW5jZV0ucHVzaChjZWxsKVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbWF4RGlzdCA9IE9iamVjdC5rZXlzKHJldmVyc2VkRGljdCkubGVuZ3RoO1xuICAgICAgICBsZXQgY3VycmVudERpc3QgPSAwO1xuICAgICAgICBjb25zdCBkaXN0YW5jZUludGVydmFsID0gc2V0SW50ZXJ2YWwoKCk9PntcbiAgICAgICAgICAgIGlmIChjdXJyZW50RGlzdCA8IG1heERpc3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjZWxscyA9IHJldmVyc2VkRGljdFtjdXJyZW50RGlzdF07XG4gICAgICAgICAgICAgICAgY2VsbHMuZm9yRWFjaCgoY2VsbCk9PntcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jZWxscyRbY2VsbF0uZmluZCgnLndhbGxzJykuY3NzKCdiYWNrZ3JvdW5kLWNvbG9yJywgZ2V0Q29sb3JGb3JOb3JtYWxpemVkRGlzdGFuY2UoY3VycmVudERpc3QgLyBtYXhEaXN0KSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY3VycmVudERpc3QrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoZGlzdGFuY2VJbnRlcnZhbCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmlzQW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy50b29sYmFyJC5maW5kKCcudG9vbC1vcHRpb24nKS5lbmFibGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgRElTVEFOQ0VfTUFQX0FOSU1BVElPTl9TUEVFRCk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNYXplRGVtb1BhZ2U7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6\n")},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "eb94bb97c3410733ce017b184d314723.png";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3N0YXRpYy9pbWFnZXMvR2l0SHViLU1hcmstTGlnaHQtNjRweC5wbmc/ZmExYyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJlYjk0YmI5N2MzNDEwNzMzY2UwMTdiMTg0ZDMxNDcyMy5wbmdcIjsiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function($) {/* harmony import */ var _less_demo_less__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9);\n/* harmony import */ var _less_demo_less__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_less_demo_less__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _less_demo_mobile_less__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);\n/* harmony import */ var _less_demo_mobile_less__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_less_demo_mobile_less__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _MazeDemoPage_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6);\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1);\n\n\n\n\n\nlet DemoPage;\n\n$(document).ready(() => {\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_3__[/* initUtils */ "b"])();\n    DemoPage = new _MazeDemoPage_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]();\n    DemoPage.startMaze();\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(4)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy9pbmRleC5qcz83YmE1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnLi4vbGVzcy9kZW1vLmxlc3MnO1xuaW1wb3J0ICcuLi9sZXNzL2RlbW8tbW9iaWxlLmxlc3MnO1xuaW1wb3J0IE1hemVEZW1vUGFnZSBmcm9tICcuL01hemVEZW1vUGFnZS5qcyc7XG5pbXBvcnQge2luaXRVdGlsc30gZnJvbSAnLi91dGlscy5qcyc7XG5cbmxldCBEZW1vUGFnZTtcblxuJChkb2N1bWVudCkucmVhZHkoKCkgPT4ge1xuICAgIGluaXRVdGlscygpO1xuICAgIERlbW9QYWdlID0gbmV3IE1hemVEZW1vUGFnZSgpO1xuICAgIERlbW9QYWdlLnN0YXJ0TWF6ZSgpO1xufSk7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8\n')},function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9sZXNzL2RlbW8ubGVzcz8yYmIwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpbiJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9\n")},function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGVzcy9kZW1vLW1vYmlsZS5sZXNzPzFiYjgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///10\n")}]);
//# sourceMappingURL=bundle.js.map